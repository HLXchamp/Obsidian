### 问题分析和实现思路

![[Pasted image 20240515202311.png]]

![[Pasted image 20240515202600.png]]

AOP见[[AOP基础]]，[[AOP进阶]]，[[AOP案例]]。

反射见[[JavaSE 笔记（六）多线程与反射#反射]]。

注解见[[JavaSE 笔记（六）多线程与反射#注解]]。
### 代码开发

新建一个@AutoFill注解：

```java
package com.sky.annotation;  
  
import com.sky.enumeration.OperationType;  
  
import java.lang.annotation.ElementType;  
import java.lang.annotation.Retention;  
import java.lang.annotation.RetentionPolicy;  
import java.lang.annotation.Target;  
  
/**  
 * 自定义注解，用于标识某个方法需要进行功能字段自动填充处理  
 */  
@Target(ElementType.METHOD)  
@Retention(RetentionPolicy.RUNTIME)  
public @interface AutoFill {  
    //数据库操作类型:update,insert  
    OperationType value();  
}
```

新建一个切面类：


```Java
/**  
 * 自定义切面类，实现功能字段自动填充处理  
 */  
@Aspect  
@Slf4j  
@Component  
public class AutoFillAspect {  
  
    /**  
     * 切入点  
     */  
    //execution减小扫描的范围，@annotation来精准定位  
    @Pointcut("execution(* com.sky.mapper.*.*(..)) && @annotation(com.sky.annotation.AutoFill)")  
    public void autoFillPointCut() {  
    }  
  
    /**  
     * 前置通知，在通知中进行公共字段的赋值  
     */  
    @Before("autoFillPointCut()")  
    public void autoFill(JoinPoint joinPoint) throws Exception {  
        log.info("开始进行公共字段自动填充...");  
  
        //获取到当前被拦截的方法上的数据库操作类型  
        MethodSignature signature = (MethodSignature) joinPoint.getSignature(); //方法签名对象  
        AutoFill autoFill = signature.getMethod().getAnnotation(AutoFill.class); //获得方法上的注解对象  
        OperationType operationType = autoFill.value(); // 获得数据库操作类型  
  
        //获取到当前被拦截的方法的参数--实体对象  
        Object[] args = joinPoint.getArgs();  
        if(args == null || args.length == 0) {  
            return;  
        }  
        Object entity = args[0];  
  
        //准备赋值的数据  
        LocalDateTime now = LocalDateTime.now();  
        Long currentId = BaseContext.getCurrentId();  
  
        //根据当前不同的操作类型，为对应的属性通过反射来赋值  
        if(operationType == OperationType.INSERT) {  
            entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class).invoke(entity, now);  
            entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class).invoke(entity, currentId);  
            entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class).invoke(entity, now);  
            entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class).invoke(entity, currentId);  
//            //也可以分开写  
//            Method setCreateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);  
//            Method setCreateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);  
//            //通过反射为对象属性赋值  
//            setCreateTime.invoke(entity,now);  
//            setCreateUser.invoke(entity,currentId);  
        }else if(operationType == OperationType.UPDATE) {  
            entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class).invoke(entity, now);  
            entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class).invoke(entity, currentId);  
        }  
    }  
}

```

在mapper里加上对应注解：

```java
@AutoFill(value = OperationType.UPDATE)  
void update(Employee employee);
```

在service上注释掉之前的对应代码：

```java
@Override  
public void update(EmployeeDTO employeeDTO) {  
    //update方法需要的是employee对象  
    Employee employee = new Employee();  
    BeanUtils.copyProperties(employeeDTO, employee);  
    //employee.setUpdateTime(LocalDateTime.now());  
    //employee.setUpdateUser(BaseContext.getCurrentId());    employeeMapper.update(employee);  
}
```

出现下面错：

![[Pasted image 20240515221543.png]]

这个错误提示表明，某个切面方法使用了`ProceedingJoinPoint`参数，但这个参数只能用于环绕通知（`@Around`）。改为`JoinPoint`就行。

### 测试

没问题。