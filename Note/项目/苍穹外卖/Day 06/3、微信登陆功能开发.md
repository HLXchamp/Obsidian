### 小程序登录原理

小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系。

#### 登录流程时序

![|625](https://res.wx.qq.com/wxdoc/dist/assets/img/api-login.2fcc9f35.jpg)

#### 说明

1. 调用 [wx.login()](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html) 获取 **临时登录凭证code** ，并回传到开发者服务器。
2. 调用 [auth.code2Session](https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/user-login/code2Session.html) 接口，换取 **用户唯一标识 OpenID** 、 用户在微信开放平台账号下的**唯一标识UnionID**（若当前小程序已绑定到微信开放平台账号） 和 **会话密钥 session_key**。

之后开发者服务器可以根据用户标识来生成自定义登录态，用于后续业务逻辑中前后端交互时识别用户身份。

#### 注意事项

1. 会话密钥 `session_key` 是对用户数据进行 [加密签名](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html) 的密钥。为了应用自身的数据安全，开发者服务器**不应该把会话密钥下发到小程序，也不应该对外提供这个密钥**。
2. 临时登录凭证 code 只能使用一次

#### 测试

![[Pasted image 20240520201227.png]]

### 需求分析与设计

![[Pasted image 20240520201440.png]]

![[Pasted image 20240520201510.png]]

![[Pasted image 20240520201706.png]]

### 代码开发

![[Pasted image 20240520201800.png]]

![[Pasted image 20240520202111.png|400]]


新建一个UserController，负责为微信用户生成JWT令牌，然后封装成UserLoginVO返回前端：

```java
@RestController  
@RequestMapping("/user/user")  
@Api(tags = "C端用户相关接口")  
@Slf4j  
public class UserController {  
  
    @Autowired  
    private UserService userService;  
  
    @Autowired  
    private JwtProperties jwtProperties;  
  
    @PostMapping("/login")  
    @ApiOperation("微信登陆")  
    public Result<UserLoginVO> login(@RequestBody UserLoginDTO userLoginDTO){  
        log.info("微信用户登录：{}",userLoginDTO.getCode());  
        //微信登陆  
        User user = userService.wxlogin(userLoginDTO);  
  
        //为微信用户生成JWT令牌  
        Map<String, Object> claims = new HashMap<>();  
        claims.put(JwtClaimsConstant.USER_ID, user.getId());  
        String token = JwtUtil.createJWT(jwtProperties.getUserSecretKey(), jwtProperties.getUserTtl(), claims);  
  
        UserLoginVO userLoginVO = UserLoginVO.builder()  
                .id(user.getId())  
                .openid(user.getOpenid())  
                .token(token)  
                .build();  
        return Result.success(userLoginVO);  
    }  
}
```

UserService：

```java
public interface UserService {  
    User wxlogin(UserLoginDTO userLoginDTO);  
}
```

UserServiceImpl，处理具体登录操作：

```java
@Service  
@Slf4j  
public class UserServiceImpl implements UserService {  
  
    public static final String WX_LOGIN = "https://api.weixin.qq.com/sns/jscode2session";  
  
    @Autowired  
    private WeChatProperties weChatProperties;  
      
    @Autowired  
    private UserMapper userMapper;  
      
    /**  
     * 实现微信登陆操作  
     * @param userLoginDTO  
     * @return  
     */  
    public User wxlogin(UserLoginDTO userLoginDTO){  
        // 获得当前微信用户的openid  
        String openId = getOpenid(userLoginDTO.getCode());  
  
        //openid为空就要抛异常  
        if(openId == null){  
            throw new LoginFailedException(MessageConstant.LOGIN_FAILED);  
        }  
  
        //判断当前用户是否是新用户  
        User user = userMapper.geyByOpenId(openId);  
  
        //如果是新用户，自动完成注册  
        if(user == null){  
            user = User.builder()  
                    .openid(openId)  
                    .createTime(LocalDateTime.now())  
                    .build();  
            userMapper.insert(user);  
        }  
  
        //返回用户对象  
        return user;  
    }  
  
    /**  
     * 调用微信接口，获得当前微信用户的openid  
     * @param code  
     * @return  
     */  
    private String getOpenid(String code) {  
        Map<String, String> map = new HashMap<>();  
        map.put("appid", weChatProperties.getAppid());  
        map.put("secret", weChatProperties.getSecret());  
        map.put("js_code", code);  
        map.put("grant_type", "authorization_code");  
  
        String json = HttpClientUtil.doGet(WX_LOGIN, map);  
  
        JSONObject jsonObject = JSONObject.parseObject(json);  
        String openId = jsonObject.getString("openid");  
        return openId;  
    }  
}
```

UserMapper：

```java
@Mapper  
public interface UserMapper {  
  
    /**  
     * 根据openID查询用户  
     * @param openId  
     * @return  
     */  
    @Select("select * from user where openid = #{openId}")  
    User geyByOpenId(String openId);  
  
    /**  
     * 插入数据  
     * @param user  
     */  
    void insert(User user);  
}
```


```xml
<!--    useGeneratedKeys="true" keyProperty="id"用于获取主键值id-->  
    <insert id="insert" useGeneratedKeys="true" keyProperty="id">  
        insert into user (openid, name, phone, sex, id_number, avatar, create_time)  
        values (#{openid}, #{name}, #{phone}, #{sex}, #{idNumber}, #{avatar}, #{createTime})    
    </insert>
```

### 测试

![[Pasted image 20240521001415.png]]

![[Pasted image 20240521001605.png]]

### 代码完善

还要编写一个拦截器校验小程序发过来的token是否合法：

JwtTokenUserInterceptor：

```java
/**  
 * jwt令牌用户端校验的拦截器  
 */  
@Component  
@Slf4j  
public class JwtTokenUserInterceptor implements HandlerInterceptor {  
  
    @Autowired  
    private JwtProperties jwtProperties;  
  
    /**  
     * 校验jwt  
     *     * @param request  
     * @param response  
     * @param handler  
     * @return  
     * @throws Exception  
     */    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {  
        //判断当前拦截到的是Controller的方法还是其他资源  
        if (!(handler instanceof HandlerMethod)) {  
            //当前拦截到的不是动态方法，直接放行  
            return true;  
        }  
  
        //1、从请求头中获取令牌  
        String token = request.getHeader(jwtProperties.getUserTokenName());  
  
        //2、校验令牌  
        try {  
            log.info("jwt校验:{}", token);  
            Claims claims = JwtUtil.parseJWT(jwtProperties.getUserSecretKey(), token);  
            Long userId = Long.valueOf(claims.get(JwtClaimsConstant.USER_ID).toString());  
            log.info("当前用户id：", userId);  
            BaseContext.setCurrentId(userId);  
            //3、通过，放行  
            return true;  
        } catch (Exception ex) {  
            //4、不通过，响应401状态码  
            response.setStatus(401);  
            return false;  
        }  
    }  
}
```

WebMvcConfiguration中注册自定义拦截器：

```java
/**  
 * 注册自定义拦截器  
 *  
 * @param registry  
 */  
protected void addInterceptors(InterceptorRegistry registry) {  
    log.info("开始注册自定义拦截器...");  
    registry.addInterceptor(jwtTokenAdminInterceptor)  
            .addPathPatterns("/admin/**")  
            .excludePathPatterns("/admin/employee/login");  
    registry.addInterceptor(jwtTokenUserInterceptor)  
            .addPathPatterns("/user/**")  
            .excludePathPatterns("/user/user/login")  
            .excludePathPatterns("/user/shop/status");  
}
```

login报错401，结果是因为排除的拦截路径写错，是/login而不是/admin！

![[Pasted image 20240521205904.png|550]]
