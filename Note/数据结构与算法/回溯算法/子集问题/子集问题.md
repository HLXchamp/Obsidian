![[Pasted image 20240420184027.png|600]]

## 思路

求子集问题和[[组合问题]]和[[分割回文串]]又不一样了。

如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，**那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！**

其实子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。

**那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！**

什么时候for可以从0开始呢？求排列问题的时候，就要从0开始，因为集合是有序的，{1, 2} 和{2, 1}是两个集合，排列问题我们后续的文章就会讲到的。

以示例中`nums = [1,2,3]`为例把求子集抽象为树型结构，如下：

![78.子集](https://code-thinking.cdn.bcebos.com/pics/78.%E5%AD%90%E9%9B%86.png)

从图中红线部分，可以看出**遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合**。

### 回溯三部曲

- 递归函数参数

和组合问题相似，要用path，res和index。

- 递归终止条件

从图中可以看出：

![78.子集](https://code-thinking.cdn.bcebos.com/pics/78.%E5%AD%90%E9%9B%86.png)

剩余集合为空的时候，就是叶子节点。就是startIndex已经大于数组的长度了，就终止了，因为没有元素可取了。

**其实可以不需要加终止条件，因为startIndex >= nums.size()，本层for循环本来也结束了**。

- 单层搜索逻辑

**求取子集问题，不需要任何剪枝！因为子集就是要遍历整棵树**。

#### 整体代码

```java
class Solution {
    List<Integer> path = new ArrayList<>();
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> subsets(int[] nums) {
        backtracking(nums, 0);
        return res;
    }
    public void backtracking(int[] nums, int index){
        res.add(new ArrayList<>(path));
        for(int i = index; i < nums.length; i++){
            path.add(nums[i]);
            backtracking(nums, i + 1);
            path.remove(path.size() - 1);
        }
        return;
    }
}
```
