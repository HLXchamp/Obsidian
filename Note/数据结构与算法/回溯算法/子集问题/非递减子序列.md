![[Pasted image 20240420190530.png|675]]

## 思路

这又是子集，又是去重，不由自主的想起了刚刚讲过的[[子集 II]]。在[[子集 II]]中我们是通过排序，再加一个标记数组来达到去重的目的。

而本题求自增子序列，是**不能对原数组进行排序**的，排完序的数组都是自增子序列了。**所以不能使用之前的去重逻辑！**

为了有鲜明的对比，用`[4, 7, 6, 7]`这个数组来举例，抽象为树形结构如图：

![491. 递增子序列1|750](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124200229824.png)

### 回溯三部曲

- 递归函数参数

本题求子序列，很明显一个元素不能重复使用，所以需要startIndex，调整下一层递归的起始位置。

- 终止条件

本题其实类似求子集问题，也是要遍历树形结构找每一个节点，所以和[[子集问题]]一样，可以不加终止条件，startIndex每次都会加1，并不会无限递归。

但本题收集结果有所不同，题目要求**递增子序列大小至少为2**，所以代码如下：

```java
if (path.size() > 1) {
    result.add(new ArrayList<>(path));
    // 注意这里不要加return，因为要取树上的所有节点
}
```

- 单层搜索逻辑

![491. 递增子序列1|750](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124200229824-20230310131640070.png) 

在图中可以看出，**同一父节点下的同层上使用过的元素就不能再使用了**

那么单层搜索代码如下：

```java
unordered_set<int> uset; // 使用set来对本层元素进行去重
for (int i = startIndex; i < nums.size(); i++) {
    if ((!path.empty() && nums[i] < path.back())
            || uset.find(nums[i]) != uset.end()) {
            continue;
    }
    uset.insert(nums[i]); // 记录这个元素在本层用过了，本层后面不能再用了
    path.add(nums[i]);
    backtracking(nums, i + 1);
    path.remove(path.size() - 1);
}
```

**对于已经习惯写回溯的同学，看到递归函数上面的`uset.insert(nums[i]);`，下面却没有对应的pop之类的操作，应该很不习惯吧**

**这也是需要注意的点，`unordered_set<int> uset;` 是记录本层元素是否重复使用，新的一层uset都会重新定义（清空），所以要知道uset只负责本层！**

也可以用**数组**做去重的操作！

#### 整体代码

```java
class Solution {
    List<Integer> path = new ArrayList<>();
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> findSubsequences(int[] nums) {
        backtracking(nums, 0);
        return res;
    }
    public void backtracking(int[] nums, int index){
        if(path.size() >= 2){
            res.add(new ArrayList<>(path)); // 千万不要return，还要向下遍历
        }
        int[] used = new int[201]; // 用数组来进行去重操作，数值范围[-100, 100]
        for(int i = index; i < nums.length; i++){
            if((!path.isEmpty() && nums[i] < path.get(path.size() - 1)) || used[100 + nums[i]] == 1){
                continue;
            }
            used[100 + nums[i]] = 1; // 不用回溯，因为每次回溯会重新生成used数组
            path.add(nums[i]);
            backtracking(nums, i + 1);
            path.remove(path.size() - 1);
        }
    }
}
```

注：判断条件不能是`i > 0 && nums[i] < nums[i - 1]`再continue！不然以下的用例不能通过，应该是和path中最后的元素比较：

![[Pasted image 20240420210219.png]]