![[Pasted image 20240418093313.png|550]]

## 思路

本题要解决如下三个问题：

1. 数字和字母如何映射
2. 两个字母就两个for循环，三个字符我就三个for循环，以此类推，然后发现代码根本写不出来
3. 输入`1 * #`按键等等异常情况

#### 数字和字母如何映射

可以使用map或者定义一个二维数组来做映射，这道题用一个**二维数组**就行。为了直接对应2-9，**新增了两个无效的字符串""**，要学会这样的写法：

```java
String[] map = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
```

#### 回溯法来解决n个for循环的问题

例如：输入："23"，抽象为树形结构，如图所示：

![17. 电话号码的字母组合](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123200304469.png)

回溯三部曲：

- 确定回溯函数参数

首先需要一个字符串s来收集叶子节点的结果，然后用一个字符串数组result保存起来。再来看参数，参数指定是有题目中给的string digits，然后还要有一个参数就是int型的index。

注意这个index可不是[[组合问题]]和[[组合总和 III]]中的index了。这个index是记录遍历第几个数字了，就是用来遍历digits的（题目中给出数字字符串），同时index也表示树的深度。

- 确定终止条件

例如输入用例"23"，两个数字，那么根节点往下递归两层就可以了，叶子节点就是要收集的结果集。那么终止条件就是如果index 等于 输入的数字个数（`digits.size`）了（本来index就是用来遍历digits的）。然后收集结果，结束本层递归。

- 确定单层遍历逻辑

首先要取index指向的数字，并找到对应的字符集（手机键盘的字符集）。然后for循环来处理这个字符集。

```java
int digit = digits.charAt(index) - '0'; // 将digits转化成数字
String letter = map[digit];
for(int i = 0; i < letter.length(); i++){ 
    path.append(letter.charAt(i));
    backtracking(digits, index + 1); // index+1，digits往后移一位 
    path.deleteCharAt(path.length() - 1);
}
```  

**注意这里for循环，可不像是在[[组合问题]]和[[组合总和 III]]中从index开始遍历的**。

**因为本题每一个数字代表的是不同集合，也就是求不同集合之间的组合，而[[组合问题]]和[[组合总和 III]]都是求同一个集合中的组合！**

注意：输入`1 * #`按键等等异常情况！代码中最好考虑这些异常情况，但题目的测试数据中应该没有异常情况的数据，所以就没有加了。**但是要知道会有这些异常，如果是现场面试中，一定要考虑到！**

完整代码：

```java
class Solution {
    StringBuilder path = new StringBuilder();
    List<String> res = new ArrayList<>();
    String[] map = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    public List<String> letterCombinations(String digits) {
        if(digits == null || digits.length() == 0){ // 不然会出现[""]的特殊情况
            return res;
        }
        backtracking(digits, 0);
        return res;
    }
    public void backtracking(String digits, int index){
        if(index == digits.length()){
            res.add(path.toString());
            return;
        }
        int digit = digits.charAt(index) - '0'; // 将digits转化成数字
        String letter = map[digit];
        for(int i = 0; i < letter.length(); i++){ // 和前两道题不同，这个i不用从index开始，因为不用在同一集合去重元素，这个是在两个集合中取元素
            path.append(letter.charAt(i));
            backtracking(digits, index + 1); // index+1，digits往后移一位 
            path.deleteCharAt(path.length() - 1);
        }
    }
}
```

注：

![[Pasted image 20240418104812.png|525]]

为了防止图中这种情况发生，一定要加上注释的这段代码，如果digits为空直接返回res！