![[Pasted image 20240418105212.png|675]]
### 思路

![[Pasted image 20240418114924.png]]

其实大部分和[[组合总和 III]]都一样，不同的是这个不用去除重复元素，例如`[2, 2]`是满足要求的。

但一定要注意取了2后，再到取5的时候就不能再取2了，不然会有重复答案类似`[2, 5]`与`[5, 2]`！

- 所以还是要有一个`index`记录下一个元素开始的位置，不然会有重复答案；
- 递归的时候就传 i 而不是`i + 1`了，`backtracking(candidates, target, i);`不然就取不到相同元素类似于`[2, 2]`了

整体代码：

```java
class Solution {
    List<Integer> path = new ArrayList<>();
    List<List<Integer>> res = new ArrayList<>();
    int sum = 0;
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        backtracking(candidates, target, 0);
        return res;
    }
    public void backtracking(int[] candidates, int target, int index){
        if(sum > target){
            return;
        }
        if(sum == target){
            res.add(new ArrayList<>(path));
            return;
        }
        for(int i = index; i < candidates.length; i++){
            path.add(candidates[i]);
            sum += candidates[i];
            backtracking(candidates, target, i); // index变为i了
            sum -= candidates[i];
            path.removeLast();
        }
    }
}
```

### 剪枝优化

![39.组合总和](https://code-thinking-1253855093.file.myqcloud.com/pics/20201223170730367-20230310135342472.png)

上面的代码大家可以看到，对于sum已经大于target的情况，其实是依然进入了下一层递归，只是下一层递归结束判断的时候，会判断`sum > target`的话就返回。

其实如果已经知道下一层的sum会大于target，就没有必要进入下一层递归了。那么可以在for循环的搜索范围上做做文章了。

**对总集合排序之后，如果下一层的sum（就是本层的 `sum + candidates[i]`）已经大于target，就可以结束本轮for循环的遍历**。

![39.组合总和1](https://code-thinking-1253855093.file.myqcloud.com/pics/20201223170809182.png)

加上剪枝的代码如下：

```java
class Solution {
    List<Integer> path = new ArrayList<>();
    List<List<Integer>> res = new ArrayList<>();
    int sum = 0;
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates); // 一定要排序！
        backtracking(candidates, target, 0);
        return res;
    }
    public void backtracking(int[] candidates, int target, int index){
        if(sum > target){
            return;
        }
        if(sum == target){
            res.add(new ArrayList<>(path));
            return;
        }
        for(int i = index; i < candidates.length && sum + candidates[i] <= target; i++){
            path.add(candidates[i]);
            sum += candidates[i];
            backtracking(candidates, target, i); // index变为i了
            sum -= candidates[i];
            path.removeLast();
        }
    }
}
```
