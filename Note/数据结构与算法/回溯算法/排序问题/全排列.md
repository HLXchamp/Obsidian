![[Pasted image 20240421192017.png|600]]

## 思路

此时我们已经学习了[[组合问题]]、[[分割回文串]]和[[子集问题]]，接下来看一看排列问题。

以`[1,2,3]`为例，抽象成树形结构如下：

![46.全排列|700](https://code-thinking-1253855093.file.myqcloud.com/pics/20211027181706.png)

### 回溯三部曲

- 递归函数参数

**首先排列是有序的，也就是说 `[1,2]` 和 `[2,1]` 是两个集合，这和之前分析的子集以及组合所不同的地方**。

可以看出元素1在`[1,2]`中已经使用过了，但是在`[2,1]`中还要在使用一次1，所以处理排列问题就**不用使用startIndex**了。

但排列问题需要一个used数组，标记已经选择的元素，如图橘黄色部分所示:

![46.全排列](https://code-thinking-1253855093.file.myqcloud.com/pics/20211027181706.png)

- 递归终止条件

可以看出叶子节点，就是收割结果的地方。当收集元素的数组path的大小达到和nums数组一样大的时候，说明找到了一个全排列，也表示到达了叶子节点。

- 单层搜索的逻辑

这里和[[组合问题]]、[[分割回文串]]和[[子集问题]]最大的不同就是for循环里不用startIndex了。因为排列问题，每次都要从头开始搜索，例如元素1在`[1,2]`中已经使用过了，但是在`[2,1]`中还要再使用一次1。

**而used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次**。

#### 整体代码

```java
class Solution {
    List<Integer> path = new ArrayList<>();
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {
        if(nums.length == 0){
            return res;
        }
        int[] used = new int[nums.length];
        backtracking(nums, used);
        return res;
    }
    public void backtracking(int[] nums, int[] used){
        if(path.size() == nums.length){ // 应该等于nums.length
            res.add(new ArrayList<>(path));
            return;
        }
        for(int i = 0; i < nums.length; i++){
            if(used[i] == 1){
                continue;
            }
            path.add(nums[i]);
            used[i] = 1;
            backtracking(nums, used);
            used[i] = 0;
            path.remove(path.size() - 1);
        }
    }
}
```

不用used数组，用`contains`方法判断path是否含有`nums[i]`：

```java
class Solution {
    List<Integer> path = new ArrayList<>();
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {
        if(nums.length == 0){
            return res;
        }
        backtracking(nums);
        return res;
    }
    public void backtracking(int[] nums){
        if(path.size() == nums.length){ // 应该等于nums.length
            res.add(new ArrayList<>(path));
            return;
        }
        for(int i = 0; i < nums.length; i++){
            if(path.contains(nums[i])){ // 判断path是否含有nums[i]
                continue;
            } 
            path.add(nums[i]);
            backtracking(nums);
            path.remove(path.size() - 1);
        }
    }
}
```
