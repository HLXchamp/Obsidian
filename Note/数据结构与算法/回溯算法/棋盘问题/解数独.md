![[Pasted image 20240422172046.png|525]]
![[Pasted image 20240422172205.png]]
## 思路

棋盘搜索问题可以使用回溯法暴力搜索，只不过这次我们要做的是**二维递归**。

[[N皇后]]是因为每一行每一列只放一个皇后，只需要一层for循环遍历一行，递归来遍历列，然后一行一列确定皇后的唯一位置。

本题就不一样了，**本题中棋盘的每一个位置都要放一个数字（而N皇后是一行只放一个皇后），并检查数字是否合法，解数独的树形结构要比N皇后更宽更深**。抽取一部分，如图所示：

![37.解数独](https://code-thinking-1253855093.file.myqcloud.com/pics/2020111720451790-20230310131816104.png)

### 回溯三部曲

- 递归函数以及参数

**递归函数的返回值需要是bool类型。** 因为解数独找到一个符合的条件（就在树的叶子节点上）立刻就返回，相当于找从根节点到叶子节点一条唯一路径，所以需要使用bool返回值。

- 递归终止条件

本题递归不用终止条件，解数独是要遍历整个树形结构寻找可能的叶子节点就立刻返回。

**不用终止条件会不会死循环？**递归的下一层的棋盘一定比上一层的棋盘多一个数，等数填满了棋盘自然就终止（填满当然好了，说明找到结果了），所以不需要终止条件！

**那么有没有永远填不满的情况呢？**这个问题我在递归单层搜索逻辑里再来讲！

- 递归单层搜索逻辑

![37.解数独](https://code-thinking-1253855093.file.myqcloud.com/pics/2020111720451790-20230310131822254.png)

在树形图中可以看出我们需要的是一个二维的递归 （一行一列）

**一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！**

```java
public boolean backtracking(char[][] board) {
        for(int i = 0; i < board.length; i++){
            for(int j = 0; j < board[0].length; j++){
                if(board[i][j] != '.'){ // 不能写成== '.'再继续，这样不满足的话就直接返回false了
                    continue;
                }
                for(char k = '1'; k <= '9'; k++){ // 一定是k <= '9'
                    if(isValid(board, i, j, k)){
                        board[i][j] = k;
                        if(backtracking(board)){
                            return true;
                        }
                        board[i][j] = '.';
                    }
                }
                return false; // 9个数都试完了，都不行，就返回false
            }
        }
        return true; // 遍历完没有返回false，说明找到了合适棋盘位置了
    }
```

**注意这里return false的地方，这里放return false 是有讲究的**。

因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！

那么会直接返回， **这也就是为什么没有终止条件也不会永远填不满棋盘而无限递归下去！**

### 判断棋盘是否合法

判断棋盘是否合法有如下三个维度：

- 同行是否重复
- 同列是否重复
- 9宫格里是否重复

#### 整体代码

```java
class Solution {
    public void solveSudoku(char[][] board) { //void型
        backtracking(board);
    }
    public boolean backtracking(char[][] board) {
        for(int i = 0; i < board.length; i++){
            for(int j = 0; j < board[0].length; j++){
                if(board[i][j] != '.'){ // 不能写成== '.'再继续，这样不满足的话就直接返回false了
                    continue;
                }
                for(char k = '1'; k <= '9'; k++){ // 一定是k <= '9'
                    if(isValid(board, i, j, k)){
                        board[i][j] = k;
                        if(backtracking(board)){
                            return true;
                        }
                        board[i][j] = '.';
                    }
                }
                return false; // 9个数都试完了，都不行，就返回false
            }
        }
        return true;
    }
    public boolean isValid(char[][] board, int row, int col, char k) {
        for(int j = 0; j < board[0].length; j++){ // 行不能重复
            if(board[row][j] == k){
                return false;
            }
        }
        for(int i = 0; i < board.length; i++){ // 列不能重复
            if(board[i][col] == k){
                return false;
            }
        }
        int rowStart = (row / 3) * 3;
        int colStart = (col / 3) * 3;
        for(int i = rowStart; i < rowStart + 3; i++){ // 九宫格里不能重复
            for(int j = colStart; j < colStart + 3; j++){
                if(board[i][j] == k){
                    return false;
                }
            }
        }
        return true;
    }
}
```
