![[Pasted image 20240327203947.png|625]]
![[Pasted image 20240327204003.png|331]]

层序遍历一个二叉树，就是从左到右一层一层的去遍历二叉树。需要**队列**来实现，**队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历（DFS）也就是递归的逻辑。**

**而这种层序遍历方式就是图论中的广度优先遍历（BFS），只不过我们应用在二叉树上。**

使用队列实现二叉树广度优先遍历，动画如下：

![102二叉树的层序遍历|600](https://code-thinking.cdn.bcebos.com/gifs/102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.gif)

这个**size**很关键！size表示每一层的节点个数，入栈后弹出size个节点，每弹出一个都把它左右孩子加进去。size保证弹出的都是同一层的。

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        Queue<TreeNode> queue = new ArrayDeque<>();
        List<List<Integer>> resList = new ArrayList<List<Integer>>();
        int size = 0;
        if(root != null){
            queue.offer(root);
        }
        else{
            return resList;
        }
        TreeNode node = root;
        while(!queue.isEmpty()){
            List<Integer> res = new ArrayList<Integer>(); // 一定要放while里，因为每次循环都要创建一个新的列表保存节点
            size = queue.size();
            while(size > 0){
                node = queue.poll();
                res.add(node.val);
                if(node.left != null){
                    queue.offer(node.left);
                }
                if(node.right != null){
                    queue.offer(node.right);
                }
                size--;
            }
            resList.add(res);
        }
        return resList;
    }
}
```

##### 注意事项：

- 保存每一层的列表`List<Integer> res`一定要放在while里，因为每次while循环都要创建一个新的列表保存节点；
- 列表的写法要熟悉：`List<List<Integer>> resList = new ArrayList<List<Integer>>();`


![[Pasted image 20240328104312.png|625]]
![[Pasted image 20240328104344.png|326]]

```java
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> resList = new ArrayList<List<Integer>>();
        int size = 0;
        Queue<TreeNode> queue = new ArrayDeque<>();
        if(root == null){
            return resList;
        }
        else{
            queue.offer(root);
        }
        TreeNode node = root;
        while(!queue.isEmpty()){
            size = queue.size();
            List<Integer> res = new ArrayList<>();
            while(size > 0){
                node = queue.poll();
                res.add(node.val);
                if(node.left != null){
                    queue.offer(node.left);
                }
                if(node.right != null){
                    queue.offer(node.right);
                }
                size--;
            }
            resList.add(res);
        }
        Collections.reverse(resList); // 没改变每层的顺序
        return resList;
    }
}
```
