![[Pasted image 20240328124234.png|425]]

第一种方法：在每次循环后在temp列表中比较一层的最大值放入res中：

```java
class Solution {
    public List<Integer> largestValues(TreeNode root) {
        Queue<TreeNode> queue = new ArrayDeque<>();
        List<Integer> res = new ArrayList<Integer>(); 
        int size = 0;
        int max = 0;
        if(root != null){
            queue.offer(root);
        }
        else{
            return res;
        }
        TreeNode node = root;
        while(!queue.isEmpty()){
            List<Integer> temp = new ArrayList<Integer>(); 
            size = queue.size();
            while(size > 0){
                node = queue.poll();
                temp.add(node.val);
                if(node.left != null){
                    queue.offer(node.left);
                }
                if(node.right != null){
                    queue.offer(node.right);
                }
                size--;
            }
            max = Collections.max(temp);
            res.add(max);
        }
        return res;
    }
}
```

第二种方法：在每一层的遍历中同时记录最大值，而不是使用额外的列表来保存每层的节点值。这样可以减少空间复杂度，并且在一次遍历中完成所有操作，从而降低时间复杂度（推荐！）。

```java
class Solution {
    public List<Integer> largestValues(TreeNode root) {
        Queue<TreeNode> queue = new ArrayDeque<>();
        List<Integer> res = new ArrayList<Integer>(); 
        int size = 0;
        if(root != null){
            queue.offer(root);
        }
        else{
            return res;
        }
        TreeNode node = root;
        while(!queue.isEmpty()){
            size = queue.size();
            int max = queue.peek().val; // 放根节点的值
            while(size > 0){
                node = queue.poll();
                max = Math.max(max, node.val); // 比较该层中的大小
                if(node.left != null){
                    queue.offer(node.left);
                }
                if(node.right != null){
                    queue.offer(node.right);
                }
                size--;
            }
            res.add(max);
        }
        return res;
    }
}
```
