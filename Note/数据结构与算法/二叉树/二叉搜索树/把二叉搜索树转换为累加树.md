![[Pasted image 20240416203716.png]]
![[Pasted image 20240416203904.png|550]]

### 思路

**其实这就是一棵树，大家可能看起来有点别扭，换一个角度来看，这就是一个有序数组`[2, 5, 13]`，求从后到前的累加数组，也就是`[20, 18, 13]`，是不是感觉这就简单了。**

数组从后向前，挨个累加就完事了，那么知道如何遍历这个二叉树，也就迎刃而解了，**从树中可以看出累加的顺序是右中左，所以我们需要反中序遍历这个二叉树，然后顺序累加就可以了**。

### 递归

![538.把二叉搜索树转换为累加树|475](https://code-thinking-1253855093.file.myqcloud.com/pics/20210204153440666.png)

本题依然需要一个prev指针记录当前遍历节点root的前一个节点，这样才方便做累加。

prev指针的使用技巧，我们在[[二叉搜索树的最小绝对差]]和[[二叉搜索树中的众数]]都提到了，这是常用的操作手段。

- 递归函数参数以及返回值

这里很明确了，不需要递归函数的返回值做什么操作了，要遍历整棵树。同时需要定义一个全局变量prev，用来保存root节点的前一个节点的数值，定义为int型就可以了。

- 确定终止条件

遇空就终止。

- 确定单层递归的逻辑

注意**要右中左来遍历二叉树**， 中节点的处理逻辑就是让root的数值加上前一个节点的数值。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int prev = 0;
    public TreeNode convertBST(TreeNode root) {
        sum(root);
        return root;
    }
    public void sum(TreeNode root){ // prev是全局变量，不用传
        if(root == null){
            return;
        }
        sum(root.right);   // 右
        root.val += prev;  // 中
        prev = root.val;
        sum(root.left);    // 左
    }
}
```
