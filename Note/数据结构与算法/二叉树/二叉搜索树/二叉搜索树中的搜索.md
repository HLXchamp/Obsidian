![[Pasted image 20240413125742.png]]
![[Pasted image 20240413125801.png|276]]

### 思路

见[[理论基础#^b7ab70]]，二叉搜索树是一个**有序树**：

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉搜索树

这就决定了，二叉搜索树，递归遍历和迭代遍历和普通二叉树都不一样。它就不用左序/右序/中序遍历了。

### 递归法
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if(root == null || root.val == val){
            return root;
        }
        TreeNode res = null; 
        if(root.val > val){
            res = searchBST(root.left, val);
        }
        if(root.val < val){
            res = searchBST(root.right, val);
        }
        return res;
    }
}
```

注：由于函数是有一个`TreeNode`的返回值的，所以我们要定义一个新的节点来接住递归返回的节点！

### 迭代法

**对于二叉搜索树，不需要回溯的过程，因为节点的有序性就帮我们确定了搜索的方向。**

例如要搜索元素为3的节点，**我们不需要搜索其他节点，也不需要做回溯，查找的路径已经规划好了。** 中间节点如果大于3就向左走，如果小于3就向右走，如图：

![二叉搜索树|325](https://code-thinking-1253855093.file.myqcloud.com/pics/20200812190213280.png)

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        while(root != null){
            if(root.val > val){
                root = root.left;
            }
            else if(root.val < val){
                root = root.right;
            }
            else{
                return root;
            }
        }
        return root;
    }
}
```
