![[Pasted image 20240413192352.png]]
![[Pasted image 20240413192410.png|208]]

### 迭代法

#### 普通二叉树统计众数

直观的方法一定是把这个树都遍历了，用map统计频率，把频率排个序，最后取前面高频的元素的集合。

具体步骤如下：

1、**遍历整个树并使用HashMap统计频率**：
 - 遍历整个二叉树，计算每个子树（包括其子节点）的和。
 - 使用HashMap来统计每个和出现的频率。HashMap的键是和的值，值是该和出现的次数。

2、**将HashMap的值转化为列表并排序**：
- 将HashMap的键值对转化为一个列表（例如，ArrayList或LinkedList），其中每个元素是一个键值对。
- 对这个列表进行排序，排序的依据是键值对的值（即和的频率）。由于我们想找出出现频率最高的子树和，所以需要降序排序。

3、**取出前面高频的元素**：
- 从排序后的列表中取出前面频率最高的元素。
- 由于列表已经按照频率降序排列，我们可以简单地检查当前元素的频率是否与最高频率相同。如果相同，我们就把当前元素加入结果列表。如果不同，说明后面的元素的频率都小于当前最高频率，因此我们可以停止遍历。

#### 搜索二叉树

可以用前面几道题的方法，其实和**双指针法**类似，prev和root就可以看作两个指针！

一般想法应该是先遍历一遍数组，找出最大频率`（maxCount）`，然后再重新遍历一遍数组把出现频率为`maxCount`的元素放进集合。（因为众数有多个）这种方式遍历了两遍数组

但这里其实只需要遍历一次就可以找到所有的众数。如果频率`count = maxCount`，当然要把这个元素加入到结果集中，`count > maxCount`的时候，不仅要更新`maxCount`，而且要**清空结果集**，因为结果集之前的元素都失效了。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    TreeNode prev = null;
    int count = 0;
    int maxCount = 0;
    ArrayList<Integer> resList = new ArrayList<>(); // 要是可变数组
    public int[] findMode(TreeNode root) {
        find(root);
        int[] res = new int[resList.size()];
        for (int i = 0; i < resList.size(); i++) {
            res[i] = resList.get(i);
        }
        return res;
    }
    public void find(TreeNode root){ // count和maxCount都是全局变量，不用传了
        if(root == null){
            return; // void类型
        }
        find(root.left);
        if(prev == null || prev.val != root.val){ // 放一起代码会简洁一点
            count = 1;
        }
        else{
            count++;
        }
        if(count == maxCount){ // 不要写成>=，要分别讨论
            resList.add(root.val);
        }
        else if(count > maxCount){
            resList.clear();
            maxCount = count;
            resList.add(root.val);
        }
        prev = root;
        find(root.right);
    }
}
```

注：
- 最开始要用`ArrayList`定义一个可变数组，因为不知道众数的个数；
-  `count`和`maxCount`都是全局变量，定义的函数就不用传了；
- `count`和`maxCount`的比较**不要写成>=**，要分>和=来讨论！