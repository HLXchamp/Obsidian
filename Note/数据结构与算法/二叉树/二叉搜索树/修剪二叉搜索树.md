![[Pasted image 20240416105809.png]]
![[Pasted image 20240416105836.png|500]]

**提示：**
- 树中节点数在范围 `[1, 10^4]` 内
- `0 <= Node.val <= 10^4`
- 树中每个节点的值都是 **唯一** 的
- 题目数据保证输入是一棵有效的二叉搜索树
- `0 <= low <= high <= 10^4`

### 递归法

**`[1, 3]`区间在二叉搜索树的中可不是单纯的节点3和左孩子节点0就决定的，还要考虑节点0的右子树**。

![669.修剪二叉搜索树|575](https://code-thinking-1253855093.file.myqcloud.com/pics/20210204155302751.png)

其实不用重构那么复杂。在上图中我们发现节点0并不符合区间要求，那么将节点0的右孩子 节点2 直接赋给 节点3的左孩子就可以了（就是把节点0从二叉树中移除），如图：

![669.修剪二叉搜索树1|500](https://code-thinking-1253855093.file.myqcloud.com/pics/20210204155327203.png)

理解了最关键部分了我们再递归三部曲：

- 确定递归函数的参数以及返回值

因为是要遍历整棵树，做修改，其实不需要返回值也可以，我们也可以完成修剪（其实就是从二叉树中移除节点）的操作。但是有返回值，更方便，可以通过递归函数的返回值来移除节点。

- 确定终止条件

修剪的操作并不是在终止条件上进行的，所以就是遇到空节点返回就可以了。

```java
if (root == null) return null;
```

- 确定单层递归的逻辑

如果root的元素小于low的数值，那么应该递归右子树，并返回右子树符合条件的头结点(这个时候就进行了**剪枝操作**)。

如果root的元素大于high的，那么应该递归左子树，并返回左子树符合条件的头结点。

接下来要将下一层处理完左子树的结果赋给root.left，处理完右子树的结果赋给root.right。

最后返回root节点。

此时大家是不是还没发现这多余的节点究竟是如何从二叉树中移除的呢？

![669.修剪二叉搜索树1|475](https://code-thinking-1253855093.file.myqcloud.com/pics/20210204155327203-20230310120126738.png)

如下代码相当于把节点0的右孩子（节点2）返回给上一层，

```java
if (root.val < low) {
    TreeNode right = trimBST(root.right, low, high); // 寻找符合区间[low, high]的节点
    return right;
}
```

然后如下代码相当于用节点3的左孩子 把下一层返回的 节点0的右孩子（节点2） 接住。

```java
root.left = trimBST(root.left, low, high);
```  

此时节点3的左孩子就变成了节点2，将节点0从二叉树中移除了。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode trimBST(TreeNode root, int low, int high) {
        if(root == null){
            return null;
        }
        if(root.val < low){
            TreeNode right = trimBST(root.right, low, high);
            return right; 
        }
        else if(root.val > high){
            TreeNode left = trimBST(root.left, low, high);
            return left; 
        }
        root.left = trimBST(root.left, low, high);
        root.right = trimBST(root.right, low, high);
        return root;
    }
}
```
