![[Pasted image 20240413131617.png|450]]
![[Pasted image 20240413131659.png|425]]

**提示：**
- 树中节点数目范围在`[1, 104]` 内
- `-2^31 <= Node.val <= 2^31 - 1`


### 思路

要知道**中序遍历**下，输出的二叉搜索树节点的数值是有序序列！

![[Pasted image 20240413195221.png|550]]

有了这个特性，**验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。**

### 递归法

一、可以递归**中序遍历**将二叉搜索树转变成一个数组，然后只要比较一下，这个数组是否是有序的，**注意二叉搜索树中不能有重复元素**。


二、其实不用转变成数组，可以在递归遍历的过程中直接判断是否有序。

这道题目比较容易陷入两个陷阱：

- 陷阱1

**不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了**。

```java
if (root.val > root.left.val && root.val < root.right.val) {
    return true;
} else {
    return false;
}
```

**我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点**。所以以上代码的判断逻辑是错误的。例如：`[10,5,15,null,null,6,20]` 这个case：

![二叉搜索树|229](https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000824.png)

- 陷阱2

样例中最小节点 可能是int的最小值，如果这样使用最小的int来比较也是不行的。

此时可以初始化比较元素为longlong的最小值。

问题可以进一步演进：如果样例中根节点的val 可能是longlong的最小值 又要怎么办呢？文中会解答。


**针对二叉搜索树的性质：**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isValidBST(TreeNode root) {
        return isValidSubtree(root, null, null);
    }

    private boolean isValidSubtree(TreeNode root, Integer min, Integer max) {
        if (root == null) {
            return true;
        }
        // 检查左子树是否在有效范围内
        if(min != null && root.val <= min){
            return false;
        }
        // 检查右子树是否在有效范围内
        if(max != null && root.val >= max){
            return false;
        }
        // 递归检查左子树和右子树
        boolean left = isValidSubtree(root.left, min, root.val);
        boolean right = isValidSubtree(root.right, root.val, max);
        return left && right;
    }
}
```
注：
- 向左走就更新最大值为头节点的值；
- 向右走就更新小值为头节点的值；
- `min != null`和`max != null`保证头节点不会被比较返回false；
- 这个不是二叉树三种遍历之一，用的二叉搜索树的性质。

**中序遍历：**

```java
class Solution {
    TreeNode prev = null; // 追踪前一个节点，一定要声明在递归函数外面，不然每次都会更新成null
    public boolean isValidBST(TreeNode root) {
        if(root == null){
            return true;
        }
        boolean left = isValidBST(root.left);
        if(!left){ // 左
            return false;
        }
        if(prev != null && root.val <= prev.val){ // 中，中序遍历一定是上一个节点prev小于当前节点root
            return false;
        }
        prev = root;
        boolean right = isValidBST(root.right); // 右
        return right;
    }
}
```

注：
- prev用来追踪上一个节点，一定要声明在递归函数外面，不然每次都会更新成null；
- 中序遍历一定是上一个节点prev的值小于当前节点root的值！
- 最后`return right`是因为左和中我们都判断过了。

### 迭代法

见[代码随想录](https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E6%80%9D%E8%B7%AF)。