![[Pasted image 20240407211838.png|301]]
![[Pasted image 20240407211902.png|336]]
![[Pasted image 20240407211920.png|475]]
### 思路

- 二叉树节点的**深度**：指从根节点到该节点的最长简单路径边的条数。
- 二叉树节点的**高度**：指从该节点到叶子节点的最长简单路径边的条数。

但leetcode中强调的深度和高度很明显是按照节点来计算的，如图：

![110.平衡二叉树2|575](https://code-thinking-1253855093.file.myqcloud.com/pics/20210203155515650.png)

因为求**深度**可以从上到下去查 所以需要**前序遍历**（中左右），而**高度**只能从下到上去查，所以只能**后序遍历**（左右中）。

### 递归

此时大家应该明白了既然要求比较高度，必然是要后序遍历。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isBalanced(TreeNode root) {
        if(height(root) == -1){
            return false;
        }
        else{
            return true;
        }
    }
    public int height(TreeNode node){
        if(node == null){
            return 0;
        }
        int leftheight = height(node.left);
        if(leftheight == -1){  // 左
            return -1;
        } 
        int rightheight = height(node.right);
        if(rightheight == -1){ // 右
            return -1;
        }
        if(Math.abs(leftheight - rightheight) > 1){
            return -1;
        }
        return 1 + Math.max(leftheight, rightheight); // 中
    }
}
```

### 迭代

在[[二叉树的最大深度]]中我们可以使用层序遍历来求深度，但是就不能直接用层序遍历来求高度了，这就体现出求高度和求深度的不同。

层序遍历（BFS）通常用于遍历二叉树的每一层，从根节点开始，逐层向下访问。虽然层序遍历可以访问二叉树的每个节点，但不能直接用它来计算二叉树的高度。这是因为层序遍历是从上到下逐层访问节点，而计算二叉树的高度需要的是从根节点到叶子节点的最长路径的长度。

较难，可以看[代码随想录的讲解](https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%9C%AC%E9%A2%98%E6%80%9D%E8%B7%AF)。