![[Pasted image 20240406190618.png]]
![[Pasted image 20240406190655.png|387]]

### 递归法

##### 方法一：对所有二叉树都使用，时间复杂度O(n)：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int countNodes(TreeNode root) {
        if(root == null){
            return 0;
        }
        int leftNum = countNodes(root.left);
        int rightNum = countNodes(root.right);
        return leftNum + rightNum + 1;
    }
}
```

##### 方法二：针对**完全二叉树**，时间复杂度更低（不用遍历所有节点）：

完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。

对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1；
对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。

 ![222.完全二叉树的节点个数|400](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124092543662.png)
 ![222.完全二叉树的节点个数1|400](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124092634138.png)

如何去判断一个左子树或者右子树是不是满二叉树呢？在完全二叉树中，如果**递归向左遍历的深度等于递归向右遍历的深度**，那说明就是满二叉树。如图：

![|425](https://code-thinking-1253855093.file.myqcloud.com/pics/20220829163554.png)

在完全二叉树中，如果递归向左遍历的深度不等于递归向右遍历的深度，则说明不是满二叉树，如图：

![|425](https://code-thinking-1253855093.file.myqcloud.com/pics/20220829163709.png)


```java
class Solution {
    // 满二叉树的结点数为：2^depth - 1
    public int countNodes(TreeNode root) {
        if (root == null){
            return 0;
        }
        TreeNode left = root.left;
        TreeNode right = root.right;
        int leftDepth = 0, rightDepth = 0; // 这里初始为0是有目的的，为了下面求指数方便
        while(left != null) {  // 求左子树深度
            left = left.left;
            leftDepth++;
        }
        while(right != null) { // 求右子树深度
            right = right.right;
            rightDepth++;
        }
        if(leftDepth == rightDepth) {
            return (2 << leftDepth) - 1; // 注意(2<<1) 相当于2^2，所以leftDepth初始为0
        }
        return countNodes(root.left) + countNodes(root.right) + 1;
    }
}
```

### 迭代法

参照[[层序遍历]]