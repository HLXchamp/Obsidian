
![[Pasted image 20240408200911.png]]
![[Pasted image 20240408200933.png|450]]

### 思路

以**后序数组的最后一个元素为切割点**，先**切中序数组**，根据中序数组，反过来**再切后序数组**。一层一层切下去，每次后序数组最后一个元素就是节点元素。流程如图：

![106.从中序与后序遍历序列构造二叉树|600](https://code-thinking-1253855093.file.myqcloud.com/pics/20210203154249860.png)


说到一层一层切割，就应该想到了递归。来看一下一共分几步：

- 第一步：如果数组大小为零的话，说明是空节点了。
- 第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。
- 第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点
- 第四步：切割中序数组，切成**中序左数组**和**中序右数组** （顺序别搞反了，一定是先切中序数组）
- 第五步：切割后序数组，切成**后序左数组**和**后序右数组**
- 第六步：递归处理左区间和右区间

用下标索引写出的代码版本（思路是一样的，只不过不用重复定义数组了，每次用下标索引来分割）：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        if(inorder.length == 0 || postorder.length == 0){
            return null;
        }
        // 左闭右开
        return bulid(inorder, 0, inorder.length, postorder, 0, postorder.length);
    }
    public TreeNode bulid(int[] inorder, int inorderStart, int inorderEnd, int[] postorder, int postorderStart, int postorderEnd){
        if(postorderEnd == postorderStart){
            return null;
        }
        int rootVal = postorder[postorderEnd - 1];
        TreeNode root = new TreeNode(rootVal);
        // if (postorderEnd - postorderStart == 1){
        //     return root;
        // }
        int temp; // 切割点
        for(temp = inorderStart; temp < inorderEnd; temp++){
            if(root.val == inorder[temp]){
                break;  // 先切中序
            }
        }
        int leftInorderStart = inorderStart; 
        int leftInorderEnd = temp;
        int rightInorderStart = temp + 1;
        int rightInorderEnd = inorderEnd;
        
        int leftPostorderStart = postorderStart; 
        int leftPostorderEnd = postorderStart + temp - inorderStart; // 是左闭右开的
        int rightPostorderStart = leftPostorderEnd; // 一定要注意
        int rightPostorderEnd = postorderEnd - 1;

        root.left = bulid(inorder, leftInorderStart, leftInorderEnd, postorder, leftPostorderStart, leftPostorderEnd);
        root.right = bulid(inorder, rightInorderStart, rightInorderEnd, postorder, rightPostorderStart, rightPostorderEnd);

        return root;
    }
}
```

注：区间表示方法一定不要变，都是左闭右开的！

### 后序和前序

前序和中序可以唯一确定一棵二叉树。后序和中序也可以唯一确定一棵二叉树。

**但前序和后序不能唯一确定一棵二叉树！**，因为没有中序遍历无法确定左右部分，也就是无法分割：

![106.从中序与后序遍历序列构造二叉树2|475](https://code-thinking-1253855093.file.myqcloud.com/pics/20210203154720326.png)

tree1 的前序遍历是`[1 2 3]`， 后序遍历是`[3 2 1]`。

tree2 的前序遍历是`[1 2 3]`， 后序遍历是`[3 2 1]`。

那么tree1 和 tree2 的前序和后序完全相同，这是一棵树么，很明显是两棵树！所以前序和后序不能唯一确定一棵二叉树！