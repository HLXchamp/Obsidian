![[Pasted image 20240412092022.png|550]]
![[Pasted image 20240412092210.png|550]]
![[Pasted image 20240412092231.png|211]]

### 思路

构造树一般采用的是**前序遍历**，因为先构造中间节点，然后递归构造左子树和右子树。

![[654.最大二叉树.gif|425]]

有两种方法，第一种是**构造新数组**，但消耗内存；第二种方法就是类似于前面的**传下标**，我们重点关注第二种写法：

其实和[[从中序与后序遍历序列构造二叉树]]差不多：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return construct(nums, 0, nums.length);
    }

    public TreeNode construct(int[] nums, int front, int end){
        if(end == front){
            return null;
        }
        if(end - front == 1){
            return new TreeNode(nums[front]); // 是返回nums[front]
        }
        int max = nums[front]; // max要等于nums[front]
        int index = front; // index不能等于0
        for(int i = front; i < end; i++){
            if(max < nums[i]){
                max = nums[i];
                index = i;
            }
        }
        TreeNode root = new TreeNode(max); // 加入根节点
        root.left = construct(nums, front, index);
        root.right = construct(nums, index + 1, end);
        return root;
    }
}
```

注：
- 第一次写很多地方都写成0了，例如`max=front[0]`, `index = 0` 这是不对的！
- 一定要搞懂区间，区间是左闭右开的，`[front, end)`，所以是从front开始，而不是0！