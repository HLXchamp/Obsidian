![[Pasted image 20240416130543.png|625]]
![[Pasted image 20240416130606.png|425]]
![[Pasted image 20240416130624.png|419]]

根据数组构造一棵二叉树。**本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间**。本题其实要比之前的题简单一些，因为有序数组构造二叉搜索树，寻找分割点就比较容易了。

分割点就是数组中间位置的节点。

那么为问题来了，如果数组长度为偶数，中间节点有两个，取哪一个都可以，只不过构成了不同的平衡二叉搜索树。例如：`[-10,-3,0,5,9]`

![108.将有序数组转换为二叉搜索树|625](https://code-thinking.cdn.bcebos.com/pics/108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.png)

如果要分割的数组长度为偶数的时候，中间元素为两个，是取左边元素 就是树1，取右边元素就是树2。

**这也是题目中强调答案不是唯一的原因。**

还有区间一定要分清楚，这里还是用的**左闭右开**。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return sort(nums, 0, nums.length);
    }
    public TreeNode sort(int[] nums, int left, int right){
        int mid = (left + right) / 2;
        if(left >= right){
            return null;
        }
        TreeNode root = new TreeNode(nums[mid]);
        root.left = sort(nums, left, mid);
        root.right = sort(nums, mid + 1, right);
        return root;
    }
}
```
