![[Pasted image 20240414201721.png]]
![[Pasted image 20240414201744.png|625]]

**提示：**
- 树中节点数目在范围 `[2, 10^5]` 内。
- `-10^9 <= Node.val <= 10^9`
- 所有 `Node.val` `互不相同` 。
- `p != q`
- `p` 和 `q` 均存在于给定的二叉树中。

## 思路

遇到这个题目首先想的是要是能自底向上查找就好了，这样就可以找到公共祖先了。那么二叉树如何可以自底向上查找呢？**二叉树回溯**的过程就是从低到上。

**后序遍历**（左右中）就是天然的回溯过程，可以根据左右子树的返回值，来处理中节点的逻辑。

如何判断一个节点是节点q和节点p的公共祖先呢。**首先最容易想到的一个情况：如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先。** 即情况一：

![|500](https://code-thinking-1253855093.file.myqcloud.com/pics/20220922173502.png)

判断逻辑是 如果递归遍历遇到q，就将q返回，遇到p 就将p返回，那么如果 左右子树的返回值**都不为空**，说明此时的中节点，一定是q 和p 的最近祖先。

**但是很多人容易忽略一个情况，就是节点本身p(q)，它拥有一个子孙节点q(p)。** 情况二：

![|500](https://code-thinking-1253855093.file.myqcloud.com/pics/20220922173530.png)

其实情况一 和 情况二 代码实现过程都是一样的，也可以说，实现情况一的逻辑，顺便包含了情况二。因为遇到 q 或者 p 就返回，这样也包含了 q 或者 p 本身就是 公共祖先的情况。

**在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）**。

那么为什么要遍历整棵树呢？直观上来看，找到最近公共祖先，直接一路返回就可以了。但事实上还要遍历根节点右子树（后序遍历）。

![236.二叉树的最近公共祖先|500](https://code-thinking-1253855093.file.myqcloud.com/pics/2021020415105872.png)

**如果left 和 right都不为空，说明此时root就是最近公共节点。这个比较好理解**，**如果left为空，right不为空，就返回right，说明目标节点是通过right返回的，反之依然**。

![236.二叉树的最近公共祖先1|500](https://code-thinking-1253855093.file.myqcloud.com/pics/20210204151125844.png)

![[Pasted image 20240415232644.png|500]]


```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null){
            return null;
        }
        if(root == p || root == q){
            return root;
        }
        TreeNode left = lowestCommonAncestor(root.left, p, q); //左
        TreeNode right = lowestCommonAncestor(root.right, p, q); // 右
        if(left != null && right != null){ // 中
            return root;
        }
        else if(left == null && right != null){
            return right;
        }
        else if(left != null && right == null){
            return left;
        }
        return null;
    }
}
```
