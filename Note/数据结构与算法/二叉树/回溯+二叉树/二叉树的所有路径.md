![[Pasted image 20240410194418.png|550]]
![[Pasted image 20240410194443.png|258]]

### 思路

这道题目要求从根节点到叶子的路径，所以需要**前序遍历**，这样才方便让父节点指向孩子节点，找到对应的路径。

在这道题目中将第一次涉及到**回溯**，因为我们要把路径记录下来，需要回溯来回退一个路径再进入另一个路径。前序遍历以及回溯的过程如图：

![257.二叉树的所有路径|550](https://code-thinking-1253855093.file.myqcloud.com/pics/20210204151702443.png)

我们先使用递归的方式，来做前序遍历。**要知道递归和回溯就是一家的，本题也需要回溯。**

### 递归

1. 递归函数参数以及返回值

要传入根节点，记录每一条路径的**paths**，和存放结果集的**result**，这里递归不需要返回值，代码如下：

```java
private void traversal(TreeNode root, List<Integer> paths, List<String> res)
```

2. 确定递归终止条件

在写递归的时候都习惯了这么写：

```java
if (cur == NULL) {
    终止处理逻辑
}
```

但是本题的终止条件这样写会很麻烦，因为本题要找到叶子节点，就开始结束的处理逻辑了（把路径放进result里）。

**那么什么时候算是找到了叶子节点？** 是当 cur不为空，其左右孩子都为空的时候，就找到叶子节点。所以本题的终止条件是：

```java
if (cur.left == NULL && cur.right == NULL) {
    终止处理逻辑
}
```

为什么没有判断cur是否为空呢，因为下面的逻辑可以控制空节点不入循环。

再来看一下终止处理的逻辑。

这里使用path来记录路径，所以要把列表结构的path转为string格式，再把这个string 放进 result里。**那么为什么使用了列表结构来记录路径呢？** 因为在下面处理单层递归逻辑的时候，要做回溯，使用列表方便来做回溯。

终止处理逻辑如下：

```java
if (root.left == null && root.right == null) {
    // 输出
    StringBuilder sb = new StringBuilder(); // StringBuilder用来拼接字符串，速度更快
    for (int i = 0; i < paths.size() - 1; i++) {
        sb.append(paths.get(i)).append("->");
    }
    sb.append(paths.get(paths.size() - 1)); // 记录最后一个节点（叶子节点）
    res.add(sb.toString()); // 收集一个路径
    return;
}
```

3. 确定单层递归逻辑

因为是前序遍历，需要先处理中间节点，中间节点就是我们要记录路径上的节点，先放进path中。

`path.add(cur.val);`

然后是递归和回溯的过程，上面说过没有判断cur是否为空，那么在这里递归的时候，如果为空就不进行下一层递归了。所以递归前要加上判断语句，下面要递归的节点是否为空，如下：

```java
if (cur.left) {
    traversal(cur.left, paths, result);
}
if (cur.right) {
    traversal(cur.right, paths, result);
}
```

此时还没完，递归完，要做回溯啊，因为path 不能一直加入节点，它还要删节点，然后才能加入新的节点。

那么回溯要怎么回溯呢，一些同学会这么写，如下：

```java
if (cur.left) {
    traversal(cur.lefts, path, result);
}
if (cur.right) {
    traversal(cur.rights, path, result);
}
path.pop_back();
```

这个回溯就有很大的问题，我们知道，**回溯和递归是一一对应的，有一个递归，就要有一个回溯**，这么写的话相当于把递归和回溯拆开了， 一个在花括号里，一个在花括号外。

**所以回溯要和递归永远在一起，世界上最遥远的距离是你在花括号里，而我在花括号外！** 那么代码应该这么写：

```java
if (cur.left) {
    traversal(cur.left, paths, result);
    paths.remove(paths.size() - 1); // 回溯
}
if (cur.right) {
    traversal(cur.right, paths, result);
    paths.remove(paths.size() - 1); // 回溯
}
```

完整代码：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        if(root == null){
            return null;
        }
        List<Integer> paths = new ArrayList<>();
        List<String> res = new ArrayList<>();
        traversal(root, paths, res);
        return res;
    }
    public void traversal(TreeNode root, List<Integer> paths, List<String> res){
        paths.add(root.val);
        if(root.left == null && root.right == null){
            StringBuilder temp = new StringBuilder();
            for(int i = 0; i < paths.size() - 1; i++){
                temp.append(paths.get(i)).append("->");
            }
            temp.append(paths.get(paths.size() - 1));// 记录最后一个节点
            res.add(temp.toString());
            return;
        }
        if(root.left != null){
            traversal(root.left, paths, res);
            paths.remove(paths.size() - 1);
        }
        if(root.right != null){
            traversal(root.right, paths, res);
            paths.remove(paths.size() - 1);
        }
    }
}
```

注：
- `StringBuilder`的应用不太熟练，`append`是追加在字符串后面的方法；
- 不要忘了录最后一个节点！