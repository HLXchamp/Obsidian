![[Pasted image 20240411101420.png|475]]
![[Pasted image 20240411101440.png|302]]

**提示:**
- 二叉树的节点个数的范围是 `[1,104]`
- `-231 <= Node.val <= 231 - 1`
### 迭代法

要注意题目意思，是最底层最左边的节点的值！所以用[[层序遍历]]会很方便，重点是要获取**当前层的第一个节点**。

最后循环用while，获取是在`while(size > 0)`外，在每一层更新后获取第一个节点
`res = queue.peek().val;`：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        Queue<TreeNode> queue = new ArrayDeque<>();
        int size = 0;
        int res = 0;
        queue.offer(root);
        while(!queue.isEmpty()){
            size = queue.size();
            res = queue.peek().val; // 每一层更新后获取第一个节点
            while (size > 0) {
            TreeNode node = queue.poll();
                if(node.left != null){
                    queue.offer(node.left);
                }
                if(node.right != null){
                    queue.offer(node.right);
                }
                size--;
            }
        }
        return res;
    }
}
```

最后循环用for，获取是在for循环里：

```java
for (int i = 0; i < size; i++) {
    TreeNode poll = queue.poll();
    if (i == 0) {
        res = poll.val;
    }
    if (poll.left != null) {
        queue.offer(poll.left);
    }
    if (poll.right != null) {
        queue.offer(poll.right);
    }
}
```

### 递归

如果使用递归法，如何判断是最后一行呢，其实就是**深度最大**的叶子节点一定是最后一行。深度和高度见[[平衡二叉树#思路]]。

那么如何找最左边的呢？可以使用前序遍历（当然中序，后序都可以，因为本题没有 中间节点的处理逻辑，只要左优先就行），保证优先左边搜索，然后记录深度最大的叶子节点，此时就是树的最后一行最左边的值。

这道题也要用到回溯法，见[代码随想录](https://programmercarl.com/0513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html#%E6%80%9D%E8%B7%AF)。

```java
class Solution {
    private int Deep = -1;
    private int value = 0;
    public int findBottomLeftValue(TreeNode root) {
        value = root.val;
        findLeftValue(root,0);
        return value;
    }

    private void findLeftValue (TreeNode root,int deep) {
        if (root == null) return;
        if (root.left == null && root.right == null) {
            if (deep > Deep) {
                value = root.val;
                Deep = deep;
            }
        }
        if (root.left != null) findLeftValue(root.left,deep + 1);
        if (root.right != null) findLeftValue(root.right,deep + 1);
    }
}
```