![[Pasted image 20240408194045.png|306]]
![[Pasted image 20240408194058.png|475]]

**判断当前节点是不是左叶子是无法判断的，必须要通过节点的父节点来判断其左孩子是不是左叶子！**

### 递归法

递归的遍历顺序为后序遍历（左右中），是因为要通过递归函数的返回值来累加求取左叶子数值之和。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if(root == null){
            return 0;
        }
        int temp = 0;
        if(root.left != null && root.left.left == null && root.left.right == null){ // 满足左子树的情况
            temp += root.left.val; 
        }
        int leftNum = sumOfLeftLeaves(root.left);    // 左
        int rightNum = sumOfLeftLeaves(root.right);  // 右
        return leftNum + rightNum + temp;            // 中
    }
}
```
 
 注：一定要加上temp，因为之后遍历左右孩子不会再遍历此节点！

### 迭代法

还是用[[层序遍历]]，一招鲜吃遍天~

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if(root == null){
            return 0;
        }
        Queue<TreeNode> queue = new ArrayDeque<>();
        queue.offer(root);
        int size = 0;
        int num = 0;
        while(!queue.isEmpty()){ // 不是root == null
            TreeNode node = null;
            size = queue.size();
            while(size > 0){
                node = queue.poll();
                if(node.left != null && node.left.left == null && node.left.right == null){ // 判断条件
                    num += node.left.val;
                }
                if(node.left != null){
                    queue.offer(node.left); // 加的是node的，不是root的
                }
                if(node.right != null){
                    queue.offer(node.right);
                }
                size--; // 在第一个循环里
            }
        }            
        return num;
    }
}
```
