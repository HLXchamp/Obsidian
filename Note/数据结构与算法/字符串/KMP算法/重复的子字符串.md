![[Pasted image 20240205205140.png|550]]

主要有两种方法：
### 一、移动匹配

一个字符串如果是由字串重复组成的，那么两个字符串拼起来（s + s），后面的子串做前串，前面的子串做后串，就一定还能组成一个s，如图：

![[Pasted image 20240206151902.png]]

我们在判断 s + s 拼接的字符串里是否出现一个s的的时候，**要刨除 s + s 的首字符和尾字符**，这样避免在s+s中搜索出原来的s，我们要搜索的是中间拼接出来的s。

### 二、KMP

看明白下面两张图就好：

**最小重复子串就是原字符串减了最长相等前（后）缀！**

![[Pasted image 20240206154119.png|500]]

等价替换原理：

![[Pasted image 20240206154130.png|550]]


```c
bool repeatedSubstringPattern(char* s) {
    int len = strlen(s);
    int* next = (int*)malloc(len * sizeof(int)); 
    int j = 0;
    next[0] = j;
    for(int i = 1; i < len; i++){
        while(j > 0 && s[i] != s[j]){
            j = next[j-1];
        }
        if(s[i] == s[j]){
            j++;
        }
        next[i] = j;
    }
    if((len % (len - next[len - 1]) == 0) && (next[len - 1] != 0)){
        return true;
    }
    else{
        return false;
    }
}
```

如果`len % (len - (next[len - 1] + 1)) == 0`，则说明数组的长度正好可以被 (数组长度-最长相等前后缀的长度) 整除 ，说明该字符串有重复的子字符串。

一定要加上`next[len - 1] != 0`，next数组最后元素是0就一定不是重复子串组成的。

![[Pasted image 20240206160632.png]]