![[Pasted image 20240130180554.png]]
![[Pasted image 20240130180607.png|600]]

#### 整体思路：
##### 1. 先翻转整个字符串
略，和之前反转字符串思路一样，用reverse函数实现，**一定要注意每个函数的返回类型！**
##### 2. 再去掉该去掉的空格
最关键的一个步骤，用removeExtraSpace函数实现。
- 首先找到首尾不为空格的start和end；
- 然后用双指针法移除空格：将start作为快指针，slow作为慢指针并赋值为0；
- `if(s[i] == ' ' && s[i+1] == ' ')  continue; `如果当前字符是空格，并且下一个字符也是空格，则跳过重新进入for循环，这样的话可以在多个单词中保留一个空格！
- 最后start指向end的下一个元素，slow指向end，将slow赋值`'\0'`改变字符串。
##### 3. 最后把每个单词再翻转一遍
 - `i <= strlen(s)`，这个小于等于不能少，要遍历完所以元素；
 - 当满足`s[i] == ' ' || s[i] == '\0'`的条件时，进入反转，`s[i] == '\0'`不能少，保证最后一个单词也能反转！
 
```c
void reverse(char *s, int start, int end){
    while(start < end){
        char temp = s[end];
        s[end] = s[start];
        s[start] = temp;
        end--;
        start++;
    }
}

void removeExtraSpace(char* s) {
    int start = 0;
    int end = strlen(s) - 1;
    while(s[start] == ' '){
        start++;
    }
    while(s[end] == ' '){
        end--;
    }
    int slow = 0;
    for(int i = start; i <= end; i++){ // 最好不要直接用start来循环，是i <= end
        if(s[i] == ' ' && s[i+1] == ' '){ // 如果当前字符是空格，并且下一个字符也是空格，则跳过
            continue;
        }
        s[slow] = s[i];
        slow++;
    }
    s[slow] = '\0'; // 形成新字符串
}

char* reverseWords(char* s) {
    int slow = 0;
    reverse(s, 0 , strlen(s)-1);
    removeExtraSpace(s);
    for(int i = 0; i <= strlen(s); i++){ // 一定要是小于等于
        if(s[i] == ' ' || s[i] == '\0'){ // s[i] == '\0'不能少，保证最后一个单词也能反转
            reverse(s, slow, i-1);
            slow = i + 1;
        }
    }
    return s;
}
```
