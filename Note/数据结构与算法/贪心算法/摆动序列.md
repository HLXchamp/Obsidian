![[Pasted image 20240423103501.png]]

### 思路 1（贪心解法）

本题要求通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。这要求最大摆动序列又可以修改数组，这得如何修改呢？

![376.摆动序列|650](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124174327597.png)

**局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值**。

**整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列**。

局部最优推出全局最优，并举不出反例，那么试试贪心！（为方便表述，以下说的峰值都是指局部峰值）

**实际操作上，其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）**

**这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点**

在计算是否有峰值的时候，大家知道遍历的下标 i ，计算 `prediff(nums[i] - nums[i-1])` 和 `curdiff(nums[i+1] - nums[i])`，如果`prediff < 0 && curdiff > 0` 或者 `prediff > 0 && curdiff < 0` 此时就有波动就需要统计。

这是我们思考本题的一个大体思路，但本题要考虑三种情况：

1. 情况一：上下坡中有平坡
2. 情况二：数组首尾两端
3. 情况三：单调坡中有平坡

#### 情况一：上下坡中有平坡

例如 `[1,2,2,2,1]`这样的数组，如图：

![|500](https://code-thinking-1253855093.file.myqcloud.com/pics/20230106170449.png)

它的摇摆序列长度是多少呢？ **其实是长度是 3**，也就是我们在删除的时候 要不删除左面的三个 2，要不就删除右边的三个 2。如图，可以统一规则，删除左边的三个 2：

![|500](https://code-thinking-1253855093.file.myqcloud.com/pics/20230106172613.png)

在图中，当 i 指向第一个 2 的时候，`prediff > 0 && curdiff = 0` ，当 i 指向最后一个 2 的时候 `prediff = 0 && curdiff < 0`。

如果我们采用，删左面三个 2 的规则，那么 当 `prediff = 0 && curdiff < 0` 也要记录一个峰值，因为他是把之前相同的元素都删掉留下的峰值。

所以我们记录峰值的条件应该是： `(preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)`，为什么这里允许 `prediff == 0` ，就是为了 上面我说的这种情况。

#### 情况二：数组首尾两端

所以本题统计峰值的时候，数组最左面和最右面如何统计呢？题目中说了，如果只有两个不同的元素，那摆动序列也是 2。

例如序列[2,5]，如果靠统计差值来计算峰值个数就需要考虑数组最左面和最右面的特殊情况。因为我们在计算 prediff 和 curdiff 的时候，至少需要三个数字才能计算，而数组只有两个数字。

这里我们**可以写死**，就是 如果只有两个元素，且元素不同，那么结果为 2。

不写死的话，可以假设，数组最前面还有一个数字，那这个数字应该是什么呢？

之前我们在讨论情况一：相同数字连续的时候，`prediff = 0` ，`curdiff < 0 或者 >0` 也记为波谷。那么为了统一，针对序列`[2,5]`，可以假设为`[2,2,5]`，这样它就有坡度了即 `preDiff = 0`，如图：

![376.摆动序列1|300](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124174357612.png)

针对以上情形，result 初始为 1（默认最右面有一个峰值），此时 `curDiff > 0 && preDiff <= 0`，那么 `result++`（计算了左面的峰值），最后得到的 result 就是 2（峰值个数为 2 即摆动序列长度为 2）。

#### 情况三：单调坡度有平坡

在版本一中，我们忽略了一种情况，如果在一个单调坡度上有平坡，例如`[1,2,2,2,3,4]`，如图：

![|500](https://code-thinking-1253855093.file.myqcloud.com/pics/20230108171505.png)

图中，我们可以看出，版本一的代码在三个地方记录峰值，但其实结果因为是 2，因为 单调中的平坡 不能算峰值（即摆动）。

之所以版本一会出问题，是因为我们实时更新了 prediff。其实只需要在这个**坡度摆动变化**的时候，**更新 prediff** 就行，这样 prediff 在 单调区间有平坡的时候 就不会发生变化，造成我们的误判。

#### 整体代码

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        int prediff = 0;
        int nextdiff = 0;
        int res = 1;
        // if(nums.length == 2){ 其实可以省略，因为prediff初始为0！
        //     if(nums[0] == nums[1]){
        //         return 1;
        //     }
        //     else{
        //         return 2;
        //     }
        // }
        for(int i = 0; i < nums.length - 1; i++){
            nextdiff = nums[i + 1] - nums[i]; // prediff不用计算，之后把nextdiff给它就行
            if(prediff >= 0 && nextdiff < 0 || prediff <= 0 && nextdiff > 0){
                res++;
                prediff = nextdiff; // 一定要放在if里
            }
        }
        return res;
    }
}
```

### 思路 2（动态规划）

