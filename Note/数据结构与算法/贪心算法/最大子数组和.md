![[Pasted image 20240423184813.png]]

## 思路

### 暴力解法

暴力解法的思路，第一层 for 就是设置起始位置，第二层 for 循环遍历数组寻找最大值：

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int result = Integer.MIN_VALUE;
        int count = 0;
        for (int i = 0; i < nums.length; i++) { // 设置起始位置
            count = 0;
            for (int j = i; j < nums.length; j++) { // 每次从起始位置i开始遍历寻找最大值
                count += nums[j];
                result = Math.max(count, result);
            }
        }
        return result;
    }
}
```

- 时间复杂度：O(n^2)
- 空间复杂度：O(1)

以上暴力的解法Java会超出时间限制！

### 贪心解法

**贪心贪的是哪里呢？** 如果 -2 和 1 在一起，计算起点的时候，一定是从 1 开始计算，因为**负数只会拉低总和**，这就是贪心贪的地方！

局部最优：当前 **“连续和”为负数的时候立刻放弃**，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。

**局部最优的情况下，并记录最大的“连续和”，可以推出全局最优**。

从代码角度上来讲：遍历 nums，从头开始用 count 累积，如果 count 一旦加上 `nums[i]`变为负数，那么就应该从`nums[i+1]`开始从 0 累积 count 了，因为已经变为负数的 count，只会拖累总和。

**这相当于是暴力解法中的不断调整最大子序和区间的起始位置**。

区间的终止位置，其实就是如果 count 取到最大值了，及时记录下来了。**这样相当于是用 result 记录最大子序和区间和（变相的算是调整了终止位置）**。

![53.最大子序和](https://code-thinking.cdn.bcebos.com/gifs/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.gif)

红色的起始位置就是贪心每次取 count 为正数的时候，开始一个区间的统计。
#### 整体代码

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int res = Integer.MIN_VALUE;
        int count = 0;
        for (int i = 0; i < nums.length; i++) { 
            count += nums[i];
            if(count > res){ // 取区间累计的最大值
                res = count;
            }
            if(count < 0){  // 相当于重置最大子序起始位置，重置的是count
                count = 0;
            }
        }
        return res;
    }
}
```

- 时间复杂度：O(n)
- 空间复杂度：O(1)

当然题目没有说如果数组为空，应该返回什么，所以数组为空的话返回啥都可以了。

### 动态规划