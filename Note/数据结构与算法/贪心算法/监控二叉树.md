![[Pasted image 20240426132719.png|425]]
![[Pasted image 20240426132752.png|600]]

## 思路

这道题目首先要想，如何放置，才能让摄像头最小的呢？从题目中示例，其实可以得到启发，**题目示例中的摄像头都没有放在叶子节点上！**

这是很重要的一个线索，摄像头可以覆盖上中下三层，如果把摄像头放在叶子节点上，就浪费的一层的覆盖。所以把摄像头放在叶子节点的父节点位置，才能充分利用摄像头的覆盖面积。

**所以我们要从下往上看，局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少！**

此时，大体思路就是从低到上，先给叶子节点父节点放个摄像头，然后隔两个节点放一个摄像头，直至到二叉树头结点。

此时这道题目还有两个难点：

1. 二叉树的遍历
2. 如何隔两个节点放一个摄像头

#### 确定遍历顺序

在二叉树中如何从低向上推导呢？可以使用**后序遍历**也就是左右中的顺序，这样就可以在回溯的过程中从下到上进行推导了。

```java
int traversal(TreeNode cur) {

    // 空节点，该节点有覆盖
    if (终止条件) return ;

    int left = traversal(cur.left);    // 左
    int right = traversal(cur.right);  // 右

    逻辑处理                            // 中
    return ;
}
```

**注意在以上代码中我们取了左孩子的返回值，右孩子的返回值，即left 和 right， 以后推导中间节点的状态**

#### 如何隔两个节点放一个摄像头

此时需要状态转移的公式，大家不要和动态的状态转移公式混到一起，本题状态转移没有择优的过程，就是单纯的状态转移！

来看看这个状态应该如何转移，先来看看每个节点可能有几种状态，有如下三种：

- 该节点无覆盖
- 本节点有摄像头
- 本节点有覆盖

我们分别有三个数字来表示：

- 0：该节点无覆盖
- 1：本节点有摄像头
- 2：本节点有覆盖

**一些同学可能会想有没有第四种状态：本节点无摄像头，其实无摄像头就是 无覆盖 或者 有覆盖的状态，所以一共还是三个状态。**

**因为在遍历树的过程中，就会遇到空节点，那么问题来了，空节点究竟是哪一种状态呢？ 空节点表示无覆盖？ 表示有摄像头？还是有覆盖呢？**

回归本质，为了让摄像头数量最少，我们要尽量让叶子节点的父节点安装摄像头，这样才能摄像头的数量最少。

那么空节点不能是无覆盖的状态，这样叶子节点就要放摄像头了，空节点也不能是有摄像头的状态，这样叶子节点的父节点就没有必要放摄像头了，而是可以把摄像头放在叶子节点的爷爷节点上。**所以空节点的状态只能是有覆盖，这样就可以在叶子节点的父节点放摄像头了**

接下来就是递推关系。那么递归的终止条件应该是遇到了空节点，此时应该返回2（有覆盖），原因上面已经解释过了。

```java
if (cur == NULL) return 2;  // 空节点，该节点有覆盖
```

递归的函数，以及终止条件已经确定了，再来看单层逻辑处理。

主要有如下四类情况：

- 情况1：左右节点都有覆盖

左孩子有覆盖，右孩子有覆盖，那么此时中间节点应该就是无覆盖的状态了。

![968.监控二叉树2|525](https://code-thinking-1253855093.file.myqcloud.com/pics/20201229203710729.png)

- 情况2：左右节点至少有一个无覆盖的情况

如果是以下情况，则中间节点（父节点）应该放摄像头：

- left == 0 && right == 0 左右节点无覆盖
- left == 1 && right == 0 左节点有摄像头，右节点无覆盖
- left == 0 && right == 1 左节点有无覆盖，右节点摄像头
- left == 0 && right == 2 左节点无覆盖，右节点覆盖
- left == 2 && right == 0 左节点覆盖，右节点无覆盖

这个不难理解，毕竟有一个孩子没有覆盖，父节点就应该放摄像头。此时摄像头的数量要加一，并且return 1，代表中间节点放摄像头。

- 情况3：左右节点至少有一个有摄像头

如果是以下情况，其实就是 左右孩子节点有一个有摄像头了，那么其父节点就应该是2（覆盖的状态）

- left == 1 && right == 2 左节点有摄像头，右节点有覆盖
- left == 2 && right == 1 左节点有覆盖，右节点有摄像头
- left == 1 && right == 1 左右节点都有摄像头

**从这个代码中，可以看出，如果left == 1, right == 0 怎么办？其实这种条件在情况2中已经判断过了**，如图：

![968.监控二叉树1|475](https://code-thinking-1253855093.file.myqcloud.com/pics/2020122920362355.png)

4. 情况4：头结点没有覆盖

以上都处理完了，递归结束之后，可能头结点 还有一个无覆盖的情况，如图：

![968.监控二叉树3|500](https://code-thinking-1253855093.file.myqcloud.com/pics/20201229203742446.png)

所以递归结束之后，还要判断根节点，如果没有覆盖，result++。

#### 整体代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int res = 0;
    public int minCameraCover(TreeNode root) {
        if(status(root) == 0){ // 加完摄像头，若根节点无覆盖，res+1
            res++;
        }
        return res;
    }
    public int status(TreeNode root){ // 0:无覆盖；1:有摄像头；2:有覆盖
        if(root == null){
            return 2;
        }
        int left = status(root.left);
        int right = status(root.right);
        if(left == 2 && right == 2){ // 左右孩子都有覆盖，root无覆盖
            return 0; // 不能root = 0；root是节点
        }
        if(left == 0 || right == 0){ // 左右孩子有一个无覆盖，root变摄像头
            res++;
            return 1;
        }
        if(left == 1 || right == 1){ // 左右孩子有一个是摄像头，root有覆盖
            return 2;
        }
        return -1;
    }
}
```
