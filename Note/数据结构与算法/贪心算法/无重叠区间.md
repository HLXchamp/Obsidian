![[Pasted image 20240425103424.png|625]]

## 思路

本题其实和[[用最少数量的箭引爆气球]]非常像，弓箭的数量就相当于是非交叉区间的数量，只要把弓箭那道题目代码里射爆气球的判断条件**加个等号**（认为`[0，1][1，2]`不是相邻区间），然后用总区间数减去弓箭数量就是要移除的区间数量了。

或者也可以直接统计重叠区间数目：**按照右边界排序，从左向右记录非交叉区间的个数。最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了**。

此时问题就是要求非交叉区间的最大个数。这里记录非交叉区间的个数还是有技巧的，如图：

![|600](https://code-thinking-1253855093.file.myqcloud.com/pics/20230201164134.png)

#### 整体代码

直接统计最大重叠个数：

```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        Arrays.sort(intervals, (a, b)->{
            return Integer.compare(a[0], b[0]); }); 
        int count = 0; // 最开始没有重叠的
        for(int i = 1; i < intervals.length; i++){
            if(intervals[i][0] >= intervals[i - 1][1]){ // 和上一道题不一样，这里等于不算重叠
                continue;
            }
            else{ 
                count++; // 这道题是统计重叠的总数
                intervals[i][1] = Math.min(intervals[i][1], intervals[i - 1][1]);
            }
        }
        return count;
    }
}
```

直接用上一题代码：

```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        Arrays.sort(intervals, (a, b)->{
            return Integer.compare(a[0], b[0]); }); 
        int res = 1;   
        for(int i = 1; i < intervals.length; i++){
            if(intervals[i][0] >= intervals[i - 1][1]){ // 要改成>=
                res++;
            }
            else{
                intervals[i][1] = Math.min(intervals[i][1], intervals[i - 1][1]); 
            }
        }
        return intervals.length - res; // 总区间数减去弓箭数量
    }
}
```
