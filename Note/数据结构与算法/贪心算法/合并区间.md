![[Pasted image 20240426095848.png|650]]
## 思路

本题的本质其实还是判断重叠区间问题。和刚刚的[[用最少数量的箭引爆气球]]、[[无重叠区间]]相都是一个套路。这几道题都是判断区间重叠，区别就是判断区间重叠后的逻辑，本题是判断区间重贴后要进行区间合并。

所以一样的套路，先排序，让所有的相邻区间尽可能的重叠在一起，按左边界，或者右边界排序都可以，处理逻辑稍有不同。

按照左边界从小到大排序之后，如果 `intervals[i][0] <= intervals[i - 1][1]` 即`intervals[i]`的左边界 `<= intervals[i - 1]`的右边界，则一定有重叠。（本题相邻区间也算重贴，所以是<=）。这么说有点抽象，看图：（**注意图中区间都是按照左边界排序之后了**）

![56.合并区间|475](https://code-thinking-1253855093.file.myqcloud.com/pics/20201223200632791.png)

知道如何判断重复之后，剩下的就是合并了，如何去模拟合并区间呢？其实就是用合并区间后左边界和右边界，**作为一个新的区间**，加入到result数组里就可以了。如果没有合并就把原区间加入到result数组。

#### 整体代码

每一次直接add添加一个intervals里的元素，如果发现重叠了就先弹出，再改变后一个元素再add。

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, (a, b) -> a[0] - b[0] );
        List<int[]> res = new ArrayList<>();
        res.add(intervals[0]);
        for(int i = 1; i < intervals.length; i++){
            if(intervals[i][0] <= intervals[i - 1][1]){
                res.remove(res.size() - 1);
                intervals[i][0] = intervals[i - 1][0];
                intervals[i][1] = Math.max(intervals[i - 1][1], intervals[i][1]);
                res.add(intervals[i]);
            }
            else{
                res.add(intervals[i]);
            }
        }
        int[][] arr = new int[res.size()][];
        for (int i = 0; i < res.size(); i++) {
            arr[i] = res.get(i);
        }
        return arr;
        // return res.stream().toArray(int[][]::new); // 使用流
    }
}
```
