![[Pasted image 20240425095730.png|650]]

## 思路

如何使用最少的弓箭呢？试一试贪心吧！局部最优：当气球出现重叠，一起射，所用弓箭最少。全局最优：把所有气球射爆所用弓箭最少。

**算法确定下来了，那么如何模拟气球射爆的过程呢？是在数组中移除元素还是做标记呢？**

如果真实的模拟射气球的过程，应该射一个，气球数组就remove一个元素，这样最直观，毕竟气球被射了。但仔细思考一下就发现：如果把气球排序之后，从前到后遍历气球，被射过的气球**仅仅跳过就行**了，没有必要让气球数组remove气球，只要记录一下箭的数量就可以了。

**为了让气球尽可能的重叠，需要对数组进行排序**。

那么按照气球起始位置排序，还是按照气球终止位置排序呢？其实都可以！只不过对应的遍历顺序不同，我就按照气球的起始位置排序了。

既然按照起始位置排序，那么就从前向后遍历气球数组，靠左尽可能让气球重复。

**如果气球重叠了，重叠气球中右边边界的最小值 之前的区间一定需要一个弓箭**。

以题目示例：`[[10,16],[2,8],[1,6],[7,12]]`为例，如图：（方便起见，已经排序）

![452.用最少数量的箭引爆气球|475](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123101929791.png)

可以看出首先第一组重叠气球，一定是需要一个箭，气球3，的左边界大于了 第一组重叠气球的最小右边界，所以再需要一支箭来射气球3了。

#### 整体代码

```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        Arrays.sort(points, (a, b)->{
            return Integer.compare(a[0], b[0]); }); // 防止溢出
        int res = 1;   // points 不为空至少需要一支箭
        for(int i = 1; i < points.length; i++){
            if(points[i][0] > points[i - 1][1]){
                res++;
            }
            else{
                points[i][1] = Math.min(points[i][1], points[i - 1][1]); //更新重叠气球最小右边界
            }
        }
        return res;
    }
}
```

注：如果写成如下形式会导致溢出，还是要写成`Integer.compare(a[0], b[0])`：

```java
Arrays.sort(points, (a, b)->{
    return (a[0] - b[0]); });
```

![[Pasted image 20240425102844.png|625]]