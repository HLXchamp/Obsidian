![[Pasted image 20240426131400.png|575]]
## 思路

###  暴力解法

题意很简单，那么首先想的就是暴力解法了，但结果会超时！

```java
class Solution {
    // 判断一个数字的各位上是否是递增
    private boolean checkNum(int num) {
        int max = 10;
        while (num > 0) {
            int t = num % 10;
            if (max >= t) max = t;
            else return false;
            num = num / 10;
        }
        return true;
    }
    public int monotoneIncreasingDigits(int N) {
        for (int i = N; i > 0; i--) { // 从大到小遍历
            if (checkNum(i)) return i;
        }
        return 0;
    }
}

```

- 时间复杂度：O(n × m) m为n的数字长度
- 空间复杂度：O(1)

### 贪心算法

题目要求小于等于N的最大单调递增的整数，那么拿一个两位的数字来举例。

例如：98，一旦出现`strNum[i - 1] > strNum[i]`的情况（非单调递增），首先想让`strNum[i - 1]--`，然后`strNum[i]`给为9，这样这个整数就是89，即小于98的最大的单调递增整数。

此时是从前向后遍历还是从后向前遍历呢？数字：332，从前向后遍历的话，那么就把变成了329，此时2又小于了第一位的3了，真正的结果应该是299。

那么从后向前遍历，就可以重复利用上次比较得出的结果了，从后向前遍历332的数值变化为：332 -> 329 -> 299。确定了遍历顺序之后，那么此时局部最优就可以推出全局，找不出反例，试试贪心。

#### 整体代码

注：一定要用一个**flag变量**来标记赋值9从哪里开始！

例如数字1000，这时候只有1<0不满足要求，变了之后是900而不是999！用一个flag标记从第一个0开始的后面都要变为9，就变成了999，正确。

```java
class Solution {
    public int monotoneIncreasingDigits(int n) {
        String str = String.valueOf(n);  // 转化成字符串
        char[] temp = str.toCharArray(); // 转化成字符数组
        int flag = temp.length;
        for(int i = temp.length - 2; i >= 0; i--){
            if(temp[i + 1] < temp[i]){
                temp[i] -= 1;
                flag = i + 1; // 定位后面全都要赋值给9的地方
            }
        }
        for(int i = flag; i < temp.length; i++){
            temp[i] = '9';
        }
        str = new String(temp);
        return Integer.parseInt(str);  // 字符串转化成int
    }
}
```
