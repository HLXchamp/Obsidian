![[Pasted image 20240425091004.png|600]]

## 思路

本题有两个维度，h和k，看到这种题目一定要想如何确定一个维度，然后再按照另一个维度重新排列。在[[分发糖果]]就强调过遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。**如果两个维度一起考虑一定会顾此失彼**。

如果按照k来从小到大排序，排完之后，会发现k的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来。

那么**按照身高h来排序**呢，身高一定是从大到小排（身高相同的话则k小的站前面），让高个子在前面。**此时我们可以确定一个维度了，就是身高，前面的节点一定都比本节点高！**

那么只需要按照k为下标重新插入队列就可以了，为什么呢？以图中{5,2} 为例：

![406.根据身高重建队列|450](https://code-thinking-1253855093.file.myqcloud.com/pics/20201216201851982.png)

所以在按照身高从大到小排序后：

**局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性**

**全局最优：最后都做完插入操作，整个队列满足题目队列属性**

回归本题，排序完的people：`[[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]]`。插入的过程：

- 插入[7,0]：`[[7,0]]`
- 插入[7,1]：`[[7,0],[7,1]]`
- 插入[6,1]：`[[7,0],[6,1],[7,1]]`
- 插入[5,0]：`[[5,0],[7,0],[6,1],[7,1]]`
- 插入[5,2]：`[[5,0],[7,0],[5,2],[6,1],[7,1]]`
- 插入[4,4]：`[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]`

#### 整体代码

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        // 身高从大到小排（身高相同k小的站前面）
        Arrays.sort(people, (a, b)->{
            if(a[0] == b[0]) return(a[1] - b[1]); //a[0] == b[0]时，根据k值升序排列
            else return(b[0] - a[0]);  //b - a 是降序排列
        });

        LinkedList<int[]> res = new LinkedList<>(); // 用链表更方便且内存消耗低
        for(int[] i : people){
            res.add(i[1], i); // 根据排序后的k值选择插入的地方
        }

        return res.toArray(new int[people.length][]);
    }
}
```
