![[Pasted image 20240423090308.png|650]]
## 思路

为了满足更多的小孩，就不要造成饼干尺寸的浪费。

大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。

**这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩**。

可以尝试使用贪心策略，先将饼干数组和小孩数组排序。然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。

![|450](https://code-thinking-1253855093.file.myqcloud.com/pics/20230405225628.png)

这个例子可以看出饼干 9 只有喂给胃口为 7 的小孩，这样才是整体最优解，并想不出反例，那么就可以撸代码了。
####   注意事项

不可以先遍历饼干，再遍历胃口呢？外面的 for 是里的下标 i 是固定移动的，而 if 里面的下标 index 是符合条件才移动的。

如果 for 控制的是饼干， if 控制胃口，就是出现如下情况 ：

![|475](https://code-thinking-1253855093.file.myqcloud.com/pics/20230112102848.png)

if 里的 index 指向 胃口 10， for 里的 i 指向饼干 9，因为 饼干 9 满足不了 胃口 10，所以 i 持续向前移动，而 index 走不到`s[index] >= g[i]` 的逻辑，所以 index 不会移动，那么当 i 持续向前移动，最后所有的饼干都匹配不上。所以 一定要 for 控制 胃口，里面的 if 控制饼干。

#### 整体代码

大饼干喂大孩子：

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(s);
        Arrays.sort(g);
        int res = 0;
        int index = s.length - 1;
        for(int i = g.length - 1; i >= 0; i--){ // 这里i可以等于0
            if(index >= 0 && s[index] >= g[i]){ // index也可以等于0
                index--;
                res++;
            }
        }
        return res;
    }
}
```

- 时间复杂度：O(nlogn)
- 空间复杂度：O(1)

小饼干喂小孩子：

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(s);
        Arrays.sort(g);
        int res = 0;
        int index = 0;
        for(int i = 0; i < s.length; i++){  // 遍历饼干s
            if(index < g.length && s[i] >= g[index]){  
                index++;
                res++;
            }
        }
        return res;
    }
}
```
