![[Pasted image 20240423193856.png|650]]

## 思路

刚看到本题一开始可能想：当前位置元素如果是 3，我究竟是跳一步呢，还是两步呢，还是三步呢，究竟跳几步才是最优呢？

其实跳几步无所谓，关键在于可跳的覆盖范围！

不一定非要明确一次究竟跳几步，每次取最大的跳跃步数，这个就是可以跳跃的覆盖范围。这个范围内，别管是怎么跳的，反正一定可以跳过来。**那么这个问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点！**

**贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点**。

局部最优推出全局最优，找不出反例，试试贪心！

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20230203105634.png)

i 每次移动只能**在 cover 的范围内移动**，每移动一个元素，cover 得到该元素数值（新的覆盖范围）的补充，让 i 继续移动下去。而 cover 每次只取 max(该元素数值补充后的范围, cover 本身范围)。

如果 cover 大于等于了终点下标，直接 return true 就可以了。

```java
class Solution {
    public boolean canJump(int[] nums) {
        if(nums.length == 1){
            return true;
        }
        int cover = 0;
        for(int i = 0; i <= cover; i++){ // i是小于等于cover(覆盖范围)，小于的话不会进入循环!
            cover = Math.max(i + nums[i], cover);
            if(cover >= nums.length - 1){
                return true;
            }
        }
        return false;
    }
}
```

- 时间复杂度: O(n)
- 空间复杂度: O(1)

