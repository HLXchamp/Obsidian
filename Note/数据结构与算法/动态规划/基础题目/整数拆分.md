![[Pasted image 20240429090057.png|625]]

**提示:**
- `2 <= n <= 58`

### 动态规划

动规五部曲，分析如下：

1. 确定dp数组（dp table）以及下标的含义

`dp[i]`：分拆数字i，可以得到的最大乘积为`dp[i]`。

2. 确定递推公式

`dp[i]`最大乘积是怎么得到的呢？其实可以从1遍历j，然后有两种渠道得到`dp[i]`.

一个是`j * (i - j)` 直接相乘。

一个是`j * dp[i - j]`，相当于是拆分(i - j)，对这个拆分不理解的话，可以回想dp数组的定义。

**那有同学问了，j怎么就不拆分呢？** j是从1开始遍历，拆分j的情况，在遍历j的过程中其实都计算过了。

那么从1遍历j，比较`(i - j) * j`和`dp[i - j] * j` 取最大的。递推公式：`dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));`

那么在取最大值的时候，为什么还要比较`dp[i]`呢？因为在递推公式推导的过程中，每次计算`dp[i]`，取最大的而已。

3. dp的初始化

`dp[0] dp[1]`应该初始化多少呢？严格从`dp[i]`的定义来说，`dp[0] dp[1]` 就不应该初始化，也就是没有意义的数值。

这里只初始化`dp[2] = 1`，从`dp[i]`的定义来说，拆分数字2，得到的最大乘积是1，这个没有任何异议！

4. 确定遍历顺序

确定遍历顺序，先看递归公式：`dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));` `dp[i]` 是依靠 `dp[i - j]`的状态，所以遍历i一定是**从前向后**遍历。

```java
for (int i = 3; i <= n ; i++) {
    for (int j = 1; j <= i / 2; j++) {
        dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
    }
}
```

注意 枚举j的时候，是从1开始的。从0开始的话，拆分一个数拆个0，求最大乘积就没有意义了。

i是从3开始，这样`dp[i - j]`就是`dp[2]`正好可以通过我们初始化的数值求出来，j 遍历，只需要遍历到 **n/2** 就可以，后面就没有必要遍历了，一定不是最大值。

5. 举例推导dp数组

举例当n为10 的时候，dp数组里的数值，如下：

![343.整数拆分|500](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104173021581.png)

#### 整体代码

```java
class Solution {
    public int integerBreak(int n) {
        int[] dp = new int[n + 1];
        dp[2] = 1;
        for(int i = 3; i <= n; i++){
            for(int j = 1; j <= i/2; j++){ // j <= i/2
                dp[i] = Math.max(j * (i - j), Math.max(j * dp[i - j], dp[i]));
            }
        }
        return dp[n];
    }
}
```

注：
- 为什么比较最大值时还要与`dp[i]`比较呢，因为每次循环j都可能会改变`dp[i]`的值，所以要记录那么多次`dp[i]`最大的值！
- `Math.max()`只能传两个参数！