![[Pasted image 20240428113723.png|650]]![[Pasted image 20240428113736.png|425]]

### 动态规划

机器人从(0 , 0) 位置出发，到(m - 1, n - 1)终点。按照动规五部曲来分析：

1. 确定dp数组（dp table）以及下标的含义

`dp[i][j]` ：表示从（0 ，0）出发，到(i, j) 有`dp[i][j]`条不同的路径。

2. 确定递推公式

想要求`dp[i][j]`，只能有两个方向来推导出来，即`dp[i - 1][j]` 和 `dp[i][j - 1]`。那么很自然，`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`，因为`dp[i][j]`只有这两个方向过来。

3. dp数组的初始化

如何初始化呢，首先`dp[i][0]`一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么`dp[0][j]`也同理。

4. 确定遍历顺序

从递推公式可知`dp[i][j]`都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。这样就可以保证推导dp[i][j]的时候，`dp[i - 1][j]` 和 `dp[i][j - 1]`一定是有数值的。

5. 举例推导dp数组

如图所示：

![62.不同路径1|475](https://code-thinking-1253855093.file.myqcloud.com/pics/20201209113631392.png)

#### 整体代码

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for(int i = 0; i < m; i++){
            dp[i][0] = 1; // dp[0][0] = 0 !
        }
        for(int j = 0; j < n; j++){
            dp[0][j] = 1;
        }
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
}
```

- 时间复杂度：O(m × n)
- 空间复杂度：O(m × n)

其实用一个一维数组（也可以理解是滚动数组）就可以了，可以优化点空间：

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[] dp = new int[n]; // 创建一个长度为n的数组dp，对应着列数
        for (int i = 0; i < n; i++) {
            dp[i] = 1; // 将数组dp的所有元素初始化为1
        }
        for (int j = 1; j < m; j++) { // 迭代行
            for (int i = 1; i < n; i++) { // 迭代列
                dp[i] += dp[i - 1]; // 更新dp[i]，每个位置的路径数量等于左边和上面的路径数量之和
            }
        }
        return dp[n - 1]; // 返回右下角的值，即为从起点到终点的唯一路径数量
    }
}
```

- 时间复杂度：O(m × n)
- 空间复杂度：O(n)