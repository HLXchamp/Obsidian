![[Pasted image 20240428103519.png]]

## 思路

题目中说 “你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯” 也就是相当于 跳到 下标 0 或者 下标 1 是不花费体力的， 从 下标 0 下标1 开始跳就要花费体力了。

1. 确定dp数组以及下标的含义

**`dp[i]`的定义：到达第i台阶所花费的最少体力。对于dp数组的定义，大家一定要清晰！**

2. 确定递推公式

**可以有两个途径得到`dp[i]`，一个是`dp[i-1]` 一个是`dp[i-2]`**。

`dp[i - 1]` 跳到 `dp[i]` 需要花费 `dp[i - 1] + cost[i - 1]`。

`dp[i - 2]` 跳到 `dp[i]` 需要花费 `dp[i - 2] + cost[i - 2]`。

那么究竟是选从dp[i - 1]跳还是从dp[i - 2]跳呢？一定是选最小的，所以`dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])`。

3. dp数组如何初始化

只初始化`dp[0]`和`dp[1]`就够了，其他的最终都是它们推出。

题目描述中明确说了 “你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。” 也就是说到达第 0/1个台阶是不花费的，但从第0/1个台阶往上跳的话，需要花费。所以初始化 `dp[0] = 0，dp[1] = 0`。

4. 确定遍历顺序

因为是模拟台阶，而且`dp[i]`由`dp[i-1]和dp[i-2]`推出，所以是**从前到后**遍历cost数组就可以了。

5. 举例推导dp数组

拿示例2：`cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]` ，来模拟一下dp数组的状态变化：

![|500](https://code-thinking-1253855093.file.myqcloud.com/pics/20221026175104.png)

#### 整体代码

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int len = cost.length;
        int[] dp = new int[len + 1];
        dp[0] = 0; // 前两个都要初始化为0
        dp[1] = 0;
        for(int i = 2; i < len + 1; i++){
            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }
        return dp[len];
    }
}
```

优化空间复杂度：

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int dp0 = 0;
        int dp1 = 0;
        for (int i = 2; i <= cost.length; i++) {
            int dpi = Math.min(dp1 + cost[i - 1], dp0 + cost[i - 2]);
            dp0 = dp1; // 记录一下前两位
            dp1 = dpi;
       return dp1;
    }
}
```

我们完成迭代时，`dp1`中存储的值就是到达顶部（数组的最后一个位置）的最小花费。