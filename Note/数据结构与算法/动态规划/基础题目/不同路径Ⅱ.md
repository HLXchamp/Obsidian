![[Pasted image 20240428195700.png|650]]
![[Pasted image 20240428195725.png|400]]

## 思路

这道题相对于[[不同路径]]就是有了障碍。[[不同路径]]中已经详细分析了没有障碍的情况，有障碍的话，其实就是标记对应的dp table（dp数组）保持初始值(0)就可以了。

动规五部曲：

1. 确定dp数组（dp table）以及下标的含义

和上一道题一样。

2. 确定递推公式

递推公式和上一道题一样。但这里需要注意一点，因为有了障碍，(i, j)如果就是障碍的话应该就保持初始状态（初始状态为0）。

3. dp数组如何初始化

和上一道题类似，但如果(i,0) 或（0,j）这条边有了障碍之后，障碍之后（包括障碍）都是走不到的位置了，所以**障碍之后的元素应该还是初始值0**。

![63.不同路径II|500](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104114513928.png)

4. 确定遍历顺序

从递归公式可以看出一定是从左到右一层一层遍历。

5. 举例推导dp数组

![[Pasted image 20240428203329.png|204]]

对应的dp table 如图：

![63.不同路径II2|278](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104114610256.png)

#### 整体代码

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int col = obstacleGrid.length;
        int row = obstacleGrid[0].length;
        int[][] dp = new int[col][row];
        dp[0][0] = (obstacleGrid[0][0] == 1) ? 0 : 1; // 起始点也可能有障碍物
        for(int i = 1; i < col; i++){ // i 从1开始
            if(obstacleGrid[i][0] == 1){
                dp[i][0] = 0;
            }
            else{
                dp[i][0] = dp[i - 1][0]; // 后面的和前面一个元素一样！前面有障碍物后面全都是0了
            }
        }
        for(int j = 1; j < row; j++){
            if(obstacleGrid[0][j] == 1){
                dp[0][j] = 0;
            }
            else{
                dp[0][j] = dp[0][j - 1];
            }
        }
        for(int i = 1; i < col; i++){
            for(int j = 1; j < row; j++){
                if(obstacleGrid[i][j] == 1){
                    dp[i][j] = 0;
                }
                else{
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }
            }
        }
        return dp[col - 1][row - 1];
    }
}
```

或者也可以这样写初始化的条件：

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int col = obstacleGrid.length;
        int row = obstacleGrid[0].length;
        int[][] dp = new int[col][row];
        if(obstacleGrid[0][0] == 1 || obstacleGrid[col - 1][row - 1] == 1){
            return 0;
        }
        for(int i = 0; i < col && obstacleGrid[i][0] == 0; i++){ // i 从0开始
            dp[i][0] = 1;
        }
        for(int j = 0; j < row && obstacleGrid[0][j] == 0; j++){
            dp[0][j] = 1;
        }
        for(int i = 1; i < col; i++){
            for(int j = 1; j < row; j++){
                dp[i][j] = (obstacleGrid[i][j] == 0) ? dp[i - 1][j] + dp[i][j - 1] : 0;
            }
        }
        return dp[col - 1][row - 1];
    }
}
```
