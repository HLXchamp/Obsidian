![[Pasted image 20240429095039.png|650]]

## 思路

![96.不同的二叉搜索树2](https://code-thinking-1253855093.file.myqcloud.com/pics/20210107093226241.png)

![[$6J515)KU9L4OHJBSJCRZQG.jpg]]

此时我们已经找到递推关系了，那么可以用动规五部曲再系统分析一遍：

1. 确定dp数组（dp table）以及下标的含义

**`dp[i]` ： 1到i为节点组成的二叉搜索树的个数**。

2. 确定递推公式

在上面的分析中，其实已经看出其递推关系，j相当于是头结点的元素，从1遍历到i为止。所以递推公式：`dp[i] += dp[j - 1] * dp[i - j];` ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量。

3. dp数组如何初始化

初始化，只需要初始化`dp[0]`就可以了，从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树。所以初始化`dp[0] = 1`。

4. 确定遍历顺序

首先一定是遍历节点数，从递归公式可以看出，节点数为i的状态是依靠 i之前节点数的状态。那么遍历i里面每一个数作为头结点的状态，用j来遍历。

5. 举例推导dp数组

n为5时候的dp数组状态如图：

![96.不同的二叉搜索树3|475](https://code-thinking-1253855093.file.myqcloud.com/pics/20210107093253987.png)

#### 整体代码

```java
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= i; j++){ // j从1开始
                dp[i] += dp[i - j] * dp[j - 1]; // 一定是累加的
            }
        }
        return dp[n];
    }
}
```
