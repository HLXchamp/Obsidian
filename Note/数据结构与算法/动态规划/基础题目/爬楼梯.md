![[Pasted image 20240427233834.png|450]]

## 思路

本题大家如果没有接触过的话，会感觉比较难，多举几个例子，就可以发现其规律。

爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。那么第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。所以到第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来，那么就可以想到动态规划了。

我们来分析一下，动规五部曲：

1. 确定dp数组以及下标的含义

`dp[i]`： 爬到第i层楼梯，有`dp[i]`种方法

2. 确定递推公式

从`dp[i]`的定义可以看出，`dp[i]` 可以有两个方向推出来。

首先是`dp[i - 1]`，上i-1层楼梯，那么再**一步跳一个台阶**不就是`dp[i]`了么。

还有就是`dp[i - 2]`，上i-2层楼梯，那么再**一步跳两个台阶**不就是`dp[i]`了么。

所以`dp[i] = dp[i - 1] + dp[i - 2]` ，和**斐波那契数列**很相似。

3. dp数组如何初始化

本题其实就不应该讨论`dp[0]`的初始化（没意义）！当然也可以向前移一位。

我相信`dp[1] = 1，dp[2] = 2`，这个初始化大家应该都没有争议的。

所以我的原则是：不考虑`dp[0]`如何初始化，只初始化`dp[1] = 1，dp[2] = 2`，然后从i = 3开始递推，这样才符合`dp[i]`的定义。

4. 确定遍历顺序

从递推公式中可以看出，遍历顺序一定是**从前向后**遍历的。

5. 举例推导dp数组

举例当n为5的时候，dp table（dp数组）应该是这样的

![70.爬楼梯|425](https://code-thinking-1253855093.file.myqcloud.com/pics/20210105202546299.png)

#### 整体代码

```java
class Solution {
    public int climbStairs(int n) {
        if(n <= 2){
            return n;
        }
        int[] dp = new int[n + 1];
        dp[1] = 1; 
        dp[2] = 2; 
        int sum = 0;
        for(int i = 3; i <= n ; i++){ // i 从3开始，因为dp[0]没有初始化
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
```

优化空间复杂度：

```java
class Solution {
    public int climbStairs(int n) {
        if(n <= 2){
            return n;
        }
        int[] dp = new int[2];
        dp[0] = 1; // 提前了一位，本来是dp[1]=1
        dp[1] = 2; // 本来是dp[2]=2
        int sum = 0;
        for(int i = 2; i <= n - 1 ; i++){ // 这里是n - 1，因为都前移了一位
            sum = dp[0] + dp[1];
            dp[0] = dp[1];
            dp[1] = sum;
        }
        return sum;
    }
}
```
