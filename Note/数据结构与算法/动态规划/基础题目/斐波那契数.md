![[Pasted image 20240427230502.png]]

### 动态规划思路

动规五部曲：

这里我们要用一个一维dp数组来保存递归的结果

1. 确定dp数组以及下标的含义

`dp[i]`的定义为：第i个数的斐波那契数值是`dp[i]`

2. 确定递推公式

为什么这是一道非常简单的入门题目呢？

**因为题目已经把递推公式直接给我们了：状态转移方程 `dp[i] = dp[i - 1] + dp[i - 2];`**

3. dp数组如何初始化

**题目中把如何初始化也直接给我们了，如下：**

```java
dp[0] = 0;
dp[1] = 1;
```

4. 确定遍历顺序

从递归公式`dp[i] = dp[i - 1] + dp[i - 2];`中可以看出，`dp[i]`是依赖 `dp[i - 1]` 和 `dp[i - 2]`，那么遍历的顺序一定是**从前到后**遍历的。

5. 举例推导dp数组

按照递推公式来推导一下，当N为10的时候，dp数组应该是如下的数列：`0 1 1 2 3 5 8 13 21 34 55`。如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。

#### 整体代码

```java
class Solution {
    public int fib(int n) {
        if(n <= 1){
            return n;
        }
        int [] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        for(int i = 2; i <= n; i++){
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
```

- 时间复杂度：O(n)
- 空间复杂度：O(n)

当然可以发现，我们只需要维护两个数值就可以了，不需要记录整个序列：

```java
class Solution {
    public int fib(int n) {
        if(n <= 1){
            return n;
        }
        int [] dp = new int[2];
        dp[0] = 0;
        dp[1] = 1;
        int sum = 0;
        for(int i = 2; i <= n; i++){ //要循环这么多次
            sum = dp[0] + dp[1];
            dp[0] = dp[1];
            dp[1] = sum;
        }
        return sum;
    }
}
```

- 时间复杂度：O(n)
- 空间复杂度：O(1)

### 递归解法

本题还可以使用递归解法来做：

```java
class Solution {
    public int fib(int n) {
        if (n <= 1) {
            return n;
        }
        return fib(n - 1) + fib(n - 2);
    }
}
```

- 时间复杂度：O(2^n)
- 空间复杂度：O(n)，算上了编程语言中实现递归的系统栈所占空间

这个递归的时间复杂度大家画一下树形图就知道了，如果不清晰的同学，可以看这篇：[通过一道面试题目，讲一讲递归算法的时间复杂度！](https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E9%80%9A%E8%BF%87%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%EF%BC%8C%E8%AE%B2%E4%B8%80%E8%AE%B2%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%81.html)

