![[Pasted image 20240510212949.png|650]]

### 双指针法

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        int sPointer = 0, tPointer = 0;
        while (sPointer < s.length() && tPointer < t.length()) {
            if (s.charAt(sPointer) == t.charAt(tPointer)) {
                sPointer++;
            }
            tPointer++;
        }
        return sPointer == s.length();
    }
}
```

### 动态规划

这道题应该算是**编辑距离**的入门题目，因为从题意中也可以发现，只需要计算删除的情况，不用考虑增加和替换的情况。和[[最长公共子序列]]其实差不多。

**所以掌握本题的动态规划解法是对后面要讲解的编辑距离的题目打下基础**。

动态规划五部曲分析如下：

1. 确定dp数组（dp table）以及下标的含义

**`dp[i][j]` 表示以下标 i-1 为结尾的字符串s，和以下标 j-1 为结尾的字符串t，相同子序列的长度为`dp[i][j]`**。

2. 确定递推公式

在确定递推公式的时候，首先要考虑如下两种操作，整理如下：

```java
 if (s[i - 1] == t[j - 1])
     t中找到了一个字符在s中也出现了
 if (s[i - 1] != t[j - 1])
     相当于t要删除元素，继续匹配
```


`if (s[i - 1] == t[j - 1])`，找到了一个相同的字符，那么`dp[i][j] = dp[i - 1][j - 1] + 1`;

`if (s[i - 1] != t[j - 1])`，此时相当于 t 要删除元素，t 如果把当前元素`t[j - 1]`删除，那么`dp[i][j]` 的数值就是 看`s[i - 1]`与 `t[j - 2]`的比较结果了，即：`dp[i][j] = dp[i][j - 1];`

和[[最长公共子序列]]的递推公式基本那就是一样的，区别就是本题如果删元素一定是字符串t，而 那道题是两个字符串都可以删元素。

3. dp数组如何初始化

从递推公式可以看出`dp[i][j]`都是依赖于`dp[i - 1][j - 1]`和 `dp[i][j - 1]`，所以`dp[0][0]`和`dp[i][0]`是一定要初始化的。

这里大家已经可以发现，在定义`dp[i][j]`含义的时候为什么要**表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为`dp[i][j]`**。

因为这样的定义在dp二维矩阵中可以留出初始化的区间，如图：

![392.判断子序列|475](https://code-thinking-1253855093.file.myqcloud.com/pics/20210303173115966.png)

4. 确定遍历顺序

同理从递推公式可以看出遍历顺序应该是从上到下，从左到右的。

![392.判断子序列1|350](https://code-thinking-1253855093.file.myqcloud.com/pics/20210303172354155.jpg)

5. 举例推导dp数组

以示例一为例，输入：s = "abc", t = "ahbgdc"，dp状态转移图如下：

![392.判断子序列2|525](https://code-thinking-1253855093.file.myqcloud.com/pics/2021030317364166.jpg)

如果`dp[s.size()][t.size()]` 与 字符串s的长度相同说明：s与t的最长相同子序列就是s，那么s 就是 t 的子序列。这也是**和[[最长公共子序列]]不同的地方**！

#### 整体代码

不需要res统计最大值：

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        char[] s1 = s.toCharArray();
        char[] t1 = t.toCharArray();
        int len1 = s1.length;
        int len2 = t1.length;
        int[][] dp = new int[len1 + 1][len2 + 1];
        for(int i = 1; i <= len1; i++){
            for(int j = 1; j <= len2; j++){
                if(s1[i - 1] == t1[j - 1]){
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else{
                    // 之前是dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
                    dp[i][j] = dp[i][j - 1];
                }
            }
        }
        return len1 == dp[len1][len2];
    }
}
```

其实也不用转化成字符数组：

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        int len1 = s.length();
        int len2 = t.length();
        int[][] dp = new int[len1 + 1][len2 + 1];
        for(int i = 1; i <= len1; i++){
            for(int j = 1; j <= len2; j++){
                if(s.charAt(i - 1) == t.charAt(j - 1)){
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else{
                    // 之前是dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
                    dp[i][j] = dp[i][j - 1];
                }
            }
        }
        return len1 == dp[len1][len2];
    }
}
```
