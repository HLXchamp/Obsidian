![[Pasted image 20240508124322.png|600]]

## 思路

首先通过本题大家要明确什么是**子序列**，“子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序”。

依然用动规五部曲来详细分析一波：

1. `dp[i]`的定义

**`dp[i]`表示i之前包括i的以`nums[i]`结尾的最长递增子序列的长度**

2. 状态转移方程

位置 i 的最长升序子序列等于 j 从0到 i-1 各个位置的最长升序子序列 + 1 的最大值。

所以：`if (nums[i] > nums[j])  dp[i] = max(dp[i], dp[j] + 1);`

3. `dp[i]`的初始化

每一个i，对应的`dp[i]`（即最长递增子序列）起始大小至少都是1.

4. 确定遍历顺序

`dp[i]` 是有0到i-1各个位置的最长递增子序列 推导而来，那么遍历i一定是从前向后遍历。

j其实就是遍历0到i-1，那么是从前到后，还是从后到前遍历都无所谓，只要吧 0 到 i-1 的元素都遍历了就行了。 所以默认习惯 从前向后遍历。遍历i的循环在外层，遍历j则在内层。

5. 举例推导dp数组

输入：`[0,1,0,3,2]`，dp数组的变化如下。结果res要取dp数组中最大的一项！

![300.最长上升子序列|425](https://code-thinking-1253855093.file.myqcloud.com/pics/20210110170945618.jpg)

#### 整体代码

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        int res = 1;
        int[] dp = new int[len];
        Arrays.fill(dp,1);
        for(int i = 1; i < len; i++){
            for(int j = 0; j < i; j++){
                if(nums[j] < nums[i]){ // 比较的是nums的长度！
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }                    
                res = Math.max(res, dp[i]);
            }
        }
        return res;
    }
}
```
