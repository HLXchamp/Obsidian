![[Pasted image 20240509173318.png|575]]

## 思路

要求两个数组中最长重复子数组，如果是暴力的解法，只需要先两层for循环确定两个数组起始位置，然后再来一个循环可以是for或者while，来从两个起始位置开始比较，取得重复子数组的长度。

本题其实是动规解决的经典题目，我们只要想到用二维数组可以记录两个字符串的所有比较情况，这样就比较好推递推公式了。 动规五部曲分析如下：

1. 确定dp数组（dp table）以及下标的含义

**`dp[i][j]` ：以下标 i - 1为结尾的A，和以下标 j - 1为结尾的B，的最长重复子数组长度。** （**特别注意**： “以下标i - 1为结尾的A” 标明一定是 以`A[i-1]`为结尾的字符串 ）

其实`dp[i][j]`的定义也就决定着，我们在遍历`dp[i][j]`的时候 i 和 j 都要从1开始。

2. 确定递推公式

即当`A[i - 1]` 和`B[j - 1]`相等的时候，`dp[i][j] = dp[i - 1][j - 1] + 1;`

3. dp数组如何初始化

根据`dp[i][j]`的定义，`dp[i][0]` 和`dp[0][j]`其实都是没有意义的！

但`dp[i][0]` 和`dp[0][j]`要初始值，因为 为了方便递归公式，`dp[i][0]` 和`dp[0][j]`初始化为0。

4. 确定遍历顺序

外层for循环遍历A，内层for循环遍历B。外层for循环遍历B，内层for循环遍历A，也行。

同时题目要求长度最长的子数组的长度。所以在遍历的时候顺便把`dp[i][j]`的最大值记录下来。

5. 举例推导dp数组

拿示例1中，A: `[1,2,3,2,1]`，B: `[3,2,1,4,7]`为例，画一个dp数组的状态变化，如下：

![718.最长重复子数组|500](https://code-thinking-1253855093.file.myqcloud.com/pics/2021011215282060.jpg)

#### 整体代码

```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int len1 = nums1.length;
        int len2 = nums2.length;
        int[][] dp = new int[len1 + 1][len2 + 1]; //明确dp数组的含义
        int res = 0;
        for(int i = 1; i <= len1; i++){ //不能从0开始，否则会越界
            for(int j = 1; j <= len2; j++){
                if(nums1[i - 1] == nums2[j - 1]){
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                res = Math.max(res, dp[i][j]);
            }
        }
        return res;
    }
}
```

- 时间复杂度：O(n × m)，n 为A长度，m为B长度
- 空间复杂度：O(n × m)