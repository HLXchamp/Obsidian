![[Pasted image 20240510205549.png|600]]

**示例 1：**
![|150](https://assets.leetcode.com/uploads/2019/04/26/142.png)
![[Pasted image 20240510205719.png]]

## 思路

相信不少录友看到这道题目都没啥思路，我们来逐步分析一下。

绘制一些连接两个数字 `A[i]` 和 `B[j]` 的直线，只要 `A[i] == B[j]`，且直线不能相交！

直线不能相交，这就是说明在字符串A中找到一个与字符串B相同的子序列，且这个子序列不能改变相对顺序，只要相对顺序不改变，链接相同数字的直线就不会相交。示例一A =`[1,4,2]`, B = `[1,2,4]`为例，相交情况如图：

![|400](https://code-thinking-1253855093.file.myqcloud.com/pics/20210914145158.png)

其实也就是说A和B的最长公共子序列是`[1,4]`，长度为2。 这个公共子序列指的是**相对顺序不变**（即数字4在字符串A中数字1的后面，那么数字4也应该在字符串B数字1的后面）

这么分析完之后，大家可以发现：**本题说是求绘制的最大连线数，其实就是求两个字符串的最长公共子序列的长度！**

那么本题就和我们刚刚讲过的这道题目[[最长公共子序列]]就是一样的了。

#### 整体代码

```java
class Solution {
    public int maxUncrossedLines(int[] nums1, int[] nums2) {
        int len1 = nums1.length;
        int len2 = nums2.length;
        //dp[i][j]表示nums1到i-1，nums2到j-1的最大值
        int[][] dp = new int[len1 + 1][len2 + 1];
        for(int i = 1; i <= len1; i++){
            for(int j = 1; j <= len2; j++){
                if(nums1[i - 1] == nums2[j - 1]){
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }  
                else{
                    dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
                }
            }
        }
        return dp[len1][len2];
    }
}
```
