![[Pasted image 20240510125825.png|650]]

## 思路

本题和[[最长重复子数组]]区别在于这里不要求是连续的了，但要有相对顺序，即："ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。

继续动规五部曲分析如下：

1. 确定dp数组（dp table）以及下标的含义

`dp[i][j]`：长度为`[0, i-1]`的字符串text1与长度为`[0, j-1]`的字符串text2的最长公共子序列。

2. 确定递推公式

如果`text1[i - 1] == text2[j - 1]`，那么找到了一个公共元素，所以`dp[i][j] = dp[i - 1][j - 1] + 1;`

如果`text1[i - 1] != text2[j - 1]`，那就看`dp[i - 1][j]`和`dp[i][j - 1]`的最长公共子序列，取最大的。即：**`dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);`** 这也是和上一道题唯一的不同点！

3. dp数组如何初始化

`test1[0, i-1]`和空串的最长公共子序列自然是0，所以`dp[i][0] = 0;`同理`dp[0][j]`也是0。

其他下标都是随着递推公式逐步覆盖，初始为多少都可以，那么就统一初始为0。

4. 确定遍历顺序

那么为了在递推的过程中，这三个方向都是经过计算的数值，所以要从前向后，从上到下来遍历。

![1143.最长公共子序列|350](https://code-thinking-1253855093.file.myqcloud.com/pics/20210204115139616.jpg)

5. 举例推导dp数组

以输入：text1 = "abcde", text2 = "ace" 为例，dp状态如图：

![1143.最长公共子序列1|425](https://code-thinking-1253855093.file.myqcloud.com/pics/20210210150215918.jpg)

#### 整体代码

不用res（`dp[len1][len2]`一定是最大的），也不用转化成字符数组：

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        char[] chars1 = text1.toCharArray();
        char[] chars2 = text2.toCharArray();
        int len1 = chars1.length;
        int len2 = chars2.length;
        int[][] dp = new int[len1 + 1][len2 + 1]; //明确dp数组的含义
        for(int i = 1; i <= len1; i++){ //不能从0开始，否则会越界
            for(int j = 1; j <= len2; j++){
                if(chars1[i - 1] == chars2[j - 1]){
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else{ // 唯一不同的地方，不用连续
                    dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]); 
                }
            }
        }
        return dp[len1][len2];
    }
}
```
