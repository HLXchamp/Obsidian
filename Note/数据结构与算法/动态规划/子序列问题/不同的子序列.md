![[Pasted image 20240511090710.png|650]]

## 思路

这道题目如果不是子序列，而是要求连续序列的，那就可以考虑用[[KMP理论基础]]。

这道题目相对于[[编辑距离]]，简单了不少，因为本题相当于只有删除操作，不用考虑替换增加之类的。

但相对于刚讲过的[[判断子序列]]就更难了，这道题目双指针法就做不了了。

1. 确定dp数组（dp table）以及下标的含义

`dp[i][j]`：以 i-1 为结尾的 s 子序列中出现以 j-1 为结尾的 t 的个数为`dp[i][j]`。

2. 确定递推公式

这一类问题，基本是要分析两种情况

- `s[i - 1]` 与 `t[j - 1]`相等
- `s[i - 1]` 与 `t[j - 1]` 不相等

当`s[i - 1] == t[j - 1]`时，`dp[i][j]`可以有两部分组成：

一部分是用`s[i - 1]`来匹配，那么个数为`dp[i - 1][j - 1]`。即不需要考虑当前s子串和t子串的最后一位字母。另一部分是不用`s[i - 1]`来匹配，个数为`dp[i - 1][j]`。

**为什么还要考虑不用`s[i - 1]`来匹配，都相同了指定要匹配啊**。

例如： s：bagg 和 t：bag ，`s[3]` 和 `t[2]`是相同的，但是字符串s也可以不用`s[3]`来匹配，即用`s[0]s[1]s[2]`组成的bag。当然也可以用`s[3]`来匹配，即：`s[0]s[1]s[3]`组成的bag。

所以当`s[i - 1] == t[j - 1]` 时，**`dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];`**

当`s[i - 1] ！= t[j - 1]`时，`dp[i][j]`只有一部分组成，不用`s[i - 1]`来匹配（就是模拟在s中删除这个元素），即：`dp[i - 1][j]`

所以递推公式为：**`dp[i][j] = dp[i - 1][j];`**

我们求的是 s 中有多少个 t，而不是求 t 中有多少个 s，所以只考虑 s 中删除元素的情况，即不用`s[i - 1]`来匹配的情况。

3. dp数组如何初始化

`dp[i][0]` 表示：以 i-1 为结尾的s可以随便删除元素，出现空字符串的个数。那么`dp[i][0]`一定都是1，因为也就是把以i-1为结尾的s，删除所有元素，出现空字符串的个数就是1。

再来看`dp[0][j]`，`dp[0][j]`：空字符串s可以随便删除元素，出现以j-1为结尾的字符串t的个数。那么`dp[0][j]`一定都是0，s如论如何也变成不了t。

`dp[0][0]`应该是1，空字符串s，可以删除0个元素，变成空字符串t。

也可以根据递推公式来推，如果相等就`dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];` 
`dp[1][1] = dp[0][0] + dp[0][1];` `dp[0][0]` 应该初始化为1，`dp[0][j]`应该初始化为0.

![|275](https://code-thinking-1253855093.file.myqcloud.com/pics/20221222165412.png)


4. 确定遍历顺序

遍历的时候一定是从上到下，从左到右。

5. 举例推导dp数组

以s："baegg"，t："bag"为例，推导dp数组状态如下：

![115.不同的子序列|425](https://code-thinking.cdn.bcebos.com/pics/115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.jpg)

#### 整体代码

```java
class Solution {
    public int numDistinct(String s, String t) {
        int len1 = s.length();
        int len2 = t.length();
        int[][] dp = new int[len1 + 1][len2 + 1];
        for(int i = 0; i <= len1; i++){
            dp[i][0] = 1; //第一列初始化为1
        }
        for(int i = 1; i <= len1; i++){
            for(int j = 1; j <= len2; j++){
                if(s.charAt(i - 1) == t.charAt(j - 1)){
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                }
                else{
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[len1][len2];
    }
}
```
