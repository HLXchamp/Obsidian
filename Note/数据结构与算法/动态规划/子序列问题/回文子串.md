![[Pasted image 20240513170245.png|525]]

**提示：**
- `1 <= s.length <= 1000`
- `s` 由小写英文字母组成

## 思路

### 暴力解法

两层for循环，遍历区间起始位置和终止位置，然后还需要一层遍历判断这个区间是不是回文。所以时间复杂度：O(n^3)

### 动态规划

动规五部曲：

1. 确定dp数组（dp table）以及下标的含义

如果和前面一些题一样，定义`dp[i]` 为 下标i结尾的字符串有 `dp[i]`个回文串的话，我们会发现很难找到递归关系。`dp[i]` 和 `dp[i-1]` ，`dp[i + 1]` 看上去都没啥关系。

所以我们要看回文串的性质。 在判断字符串S是否是回文时，如果我们知道 `s[1]`，`s[2]`，`s[3]` 这个子串是回文的，那么只需要比较 `s[0]`和`s[4]`这两个元素是否相同，如果相同的话，这个字符串s 就是回文串。

![|400](https://code-thinking-1253855093.file.myqcloud.com/pics/20230102170752.png)

那么此时我们是不是能找到一种递归关系，也就是判断一个子字符串（字符串的下表范围`[i,j]`）是否回文，依赖于子字符串（下表范围`[i + 1, j - 1]`）） 是否是回文。

所以为了明确这种递归关系，我们的dp数组是要定义成一位二维dp数组。

**布尔类型的`dp[i][j]`：表示区间范围`[i,j]` （注意是左闭右闭）的子串是否是回文子串**，如果是`dp[i][j]`为true，否则为false。

2. 确定递推公式

在确定递推公式时，就要分析两种情况，就是`s[i]`与`s[j]`相等，`s[i]`与`s[j]`不相等这两种。

当`s[i]`与`s[j]`不相等，`dp[i][j]`一定是false，此时不用操作，因为默认是false。

当`s[i]`与`s[j]`相等时，这就复杂一些了，有如下三种情况

- 情况一：下标 i 与 j 相同，同一个字符例如a，当然是回文子串
- 情况二：下标 i 与 j 相差为1，例如aa，也是回文子串
- 情况三：下标：i 与 j 相差大于1的时候，例如cabac，此时`s[i]`与`s[j]`已经相同了，我们看 i 到 j 区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看`dp[i + 1][j - 1]`是否为true。

以上三种情况分析完了，那么递归公式如下（用result统计回文次数）：

```java
if (s[i] == s[j]) {
    if (j - i <= 1) { // 情况一 和 情况二
        result++;
        dp[i][j] = true;
    } else if (dp[i + 1][j - 1]) { // 情况三
        result++;
        dp[i][j] = true;
    }
}
```

3. dp数组如何初始化

`dp[i][j]`初始化为false。

4. 确定遍历顺序

遍历顺序可有有点讲究了。首先从递推公式中可以看出，情况三是根据`dp[i + 1][j - 1]`是否为true，在对`dp[i][j]`进行赋值true的。

`dp[i + 1][j - 1]` 在 `dp[i][j]`的左下角。**所以一定要从下到上，从左到右遍历，这样保证dp`[i + 1][j - 1]`都是经过计算的**。

![647.回文子串|300](https://code-thinking-1253855093.file.myqcloud.com/pics/20210121171032473-20230310132134822.jpg)

5. 举例推导dp数组

举例，输入："aaa"，`dp[i][j]`状态如下：

![647.回文子串1|350](https://code-thinking-1253855093.file.myqcloud.com/pics/20210121171059951-20230310132153163.jpg)

图中有6个true，所以就是有6个回文子串。

#### 整体代码

```java
class Solution {
    public int countSubstrings(String s) {
        int len = s.length();
        //区间是[i,j]，boolean数组默认填充为false，这里是[len][len]和前面不一样
        boolean[][] dp = new boolean[len][len]; 
        // Arrays.fill(dp, false); //Arrays.fill()方法只能填充一维数组的元素
        int res = 0;
        for(int i = len - 1; i >= 0; i--){
            for(int j = i; j < len; j++){
                if(s.charAt(i) == s.charAt(j)){
                    if(j - i <= 1){ //j的坐标比i大
                        dp[i][j] = true;
                        res++;
                    }
                    else if(dp[i + 1][j - 1]){
                        dp[i][j] = true;
                        res++;
                    }
                }
            }
        }
        return res;
    }
}
```

以上代码可以简洁一下的，如下：

```java
class Solution {
    public int countSubstrings(String s) {
        int len = s.length();
        // 区间是[i,j]，boolean数组默认填充为false，这里是[len][len]和前面不一样
        boolean[][] dp = new boolean[len][len];
        int res = 0;
        for (int i = len - 1; i >= 0; i--) {
            for (int j = i; j < len; j++) {
                if (s.charAt(i) == s.charAt(j) && (j - i <= 1 || dp[i + 1][j - 1])) {
                    dp[i][j] = true;
                    res++;
                }
            }
        }
        return res;
    }
}
```

- 时间复杂度：O(n^2)
- 空间复杂度：O(n^2)

### 双指针法

动态规划的空间复杂度是偏高的，我们再看一下双指针法。

首先确定回文串，就是找中心然后向两边扩散看是不是对称的就可以了。**在遍历中心点的时候，要注意中心点有两种情况**。

一个元素可以作为中心点，两个元素也可以作为中心点。

那么有人同学问了，三个元素还可以做中心点呢。其实三个元素就可以由一个元素左右添加元素得到，四个元素则可以由两个元素左右添加元素得到。

所以我们在计算的时候，要注意一个元素为中心点和两个元素为中心点的情况。

**这两种情况可以放在一起计算，但分别计算思路更清晰，我倾向于分别计算**，代码如下：

```
class Solution {
public:
    int countSubstrings(string s) {
        int result = 0;
        for (int i = 0; i < s.size(); i++) {
            result += extend(s, i, i, s.size()); // 以i为中心
            result += extend(s, i, i + 1, s.size()); // 以i和i+1为中心
        }
        return result;
    }
    int extend(const string& s, int i, int j, int n) {
        int res = 0;
        while (i >= 0 && j < n && s[i] == s[j]) {
            i--;
            j++;
            res++;
        }
        return res;
    }
};
```

1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  
13  
14  
15  
16  
17  
18  
19  
20  

- 时间复杂度：O(n^2)
- 空间复杂度：O(1)




