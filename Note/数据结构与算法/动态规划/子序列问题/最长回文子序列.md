![[Pasted image 20240513170333.png|575]]

**提示：**
- `1 <= s.length <= 1000`
- `s` 仅由小写英文字母组成

## 思路

上一道题[[回文子串]]求的是回文子串，而本题要求的是回文子序列， 要搞清楚这两者之间的区别。

**回文子串是要连续的，回文子序列可不是连续的！** 

回文子串，可以做这两题：

- 647.回文子串
- 5.最长回文子串

思路其实是差不多的，但本题要比求回文子串简单一点，因为情况少了一点。

动规五部曲分析如下：

1. 确定dp数组（dp table）以及下标的含义

**`dp[i][j]`：字符串s在`[i, j]`范围内最长的回文子序列的长度为`dp[i][j]`**。

2. 确定递推公式

在判断回文子串的题目中，关键逻辑就是看`s[i]`与`s[j]`是否相同。

如果`s[i]`与`s[j]`相同，那么`dp[i][j]` = `dp[i + 1][j - 1] + 2;`

![516.最长回文子序列|475](https://code-thinking-1253855093.file.myqcloud.com/pics/20210127151350563.jpg)

如果`s[i]`与`s[j]`不相同，说明`s[i]`和`s[j]`的同时加入并不能增加`[i,j]`区间回文子序列的长度，那么分别加入`s[i]`、`s[j]`看看哪一个可以组成最长的回文子序列。

加入`s[j]`的回文子序列长度为`dp[i + 1][j]`。加入`s[i]`的回文子序列长度为`dp[i][j - 1]`。

那么`dp[i][j]`一定是取最大的，即：`dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);`

![516.最长回文子序列1|475](https://code-thinking-1253855093.file.myqcloud.com/pics/20210127151420476.jpg)


3. dp数组如何初始化

首先要考虑当 i 和 j 相同的情况，从递推公式可以看出递推公式是计算不到 i 和 j 相同时候的情况。当 i 与 j 相同，那么`dp[i][j]`一定是等于1的，即：一个字符的回文子序列长度就是1。

其他情况`dp[i][j]`初始为0就行。


4. 确定遍历顺序

从递归公式中可以看出，**遍历 i 的时候一定要从下到上遍历，这样才能保证下一行的数据是经过计算的**。j 的话，可以正常从左向右遍历。

![|250](https://code-thinking-1253855093.file.myqcloud.com/pics/20230102172155.png)


5. 举例推导dp数组

输入s:"cbbd" 为例，dp数组状态如图：

![516.最长回文子序列3|375](https://code-thinking-1253855093.file.myqcloud.com/pics/20210127151521432.jpg)

红色框即：`dp[0][s.size() - 1];` 为最终结果。

#### 整体代码


```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int len = s.length();
        int[][] dp = new int[len][len];
        for(int i = 0; i < len; i++){
            dp[i][i] = 1;
        }
        for(int i = len - 1; i >= 0; i--){ // i可以等于0
            for(int j = i + 1; j < len; j++){ // j从1+1开始，因为j=i的情况已经初始化过了
                if(s.charAt(i) == s.charAt(j)){
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                }
                else{
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[0][len - 1];
    }
}
```
