![[Pasted image 20240511102134.png|525]]

## 思路
### 动态规划一

本题和[[最长公共子序列]]基本相同，只要求出两个字符串的最长公共子序列长度即可，那么除了最长公共子序列之外的字符都是必须删除的，最后用两个字符串的总长度减去两个最长公共子序列的长度就是删除的最少步数。代码如下：

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int len1 = word1.length();
        int len2 = word2.length();
        int[][] dp = new int[len1 + 1][len2 + 1];
        for(int i = 1; i <= len1; i++){ 
            for(int j = 1; j <= len2; j++){
                if(word1.charAt(i - 1) == word2.charAt(j - 1)){
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else{ 
                    dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]); 
                }
            }
        }
        return len1 + len2 - dp[len1][len2] * 2;
    }
}
```

- 时间复杂度: O(n * m)
- 空间复杂度: O(n * m)

### 动态规划二

本题和[[不同的子序列]]相比，其实就是两个字符串都可以删除了，情况虽说复杂一些，但整体思路是不变的。

1. 确定dp数组（dp table）以及下标的含义

`dp[i][j]`：以 i-1 为结尾的字符串word1，和以 j-1 位结尾的字符串word2，想要达到相等，所需要**删除元素的最少次数**。

2. 确定递推公式

- 当`word1[i - 1]` 与 `word2[j - 1]`相同的时候
- 当`word1[i - 1]` 与 `word2[j - 1]`不相同的时候

当`word1[i - 1]` 与 `word2[j - 1]`相同的时候，`dp[i][j] = dp[i - 1][j - 1]`;也就是不用删元素。

当`word1[i - 1]` 与 `word2[j - 1]`不相同的时候，有三种情况：

- 删`word1[i - 1]`，最少操作次数为`dp[i - 1][j] + 1`
- 删`word2[j - 1]`，最少操作次数为`dp[i][j - 1] + 1`
- 同时删`word1[i - 1]`和`word2[j - 1]`，操作的最少次数为`dp[i - 1][j - 1] + 2`

因为 `dp[i][j - 1] + 1 = dp[i - 1][j - 1] + 2`，所以递推公式可简化为：**`dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);

3. dp数组如何初始化

`dp[i][0]`：word2为空字符串，以 i-1 为结尾（**i - 1是下标，总共有 i 个元素**）的字符串word1要删除多少个元素，才能和word2相同呢，很明显`dp[i][0] = i`。

`dp[0][j]`的话同理，`dp[0][j] = j`。`dp[0][0] = 0`（不需要删除元素）。

4. 确定遍历顺序

从上到下，从左到右。

5. 举例推导dp数组

以word1:"sea"，word2:"eat"为例，推导dp数组状态图如下：

![583.两个字符串的删除操作1|375](https://code-thinking-1253855093.file.myqcloud.com/pics/20210714101750205.png)

#### 整体代码

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int len1 = word1.length();
        int len2 = word2.length();
        int[][] dp = new int[len1 + 1][len2 + 1];
        for (int i = 0; i <= len1; i++) {
            dp[i][0] = i;
        }
        for (int j = 0; j <= len2; j++) {
            dp[0][j] = j;
        }
        for(int i = 1; i <= len1; i++){ 
            for(int j = 1; j <= len2; j++){
                if(word1.charAt(i - 1) == word2.charAt(j - 1)){
                    dp[i][j] = dp[i - 1][j - 1];
                }
                else{ 
                    dp[i][j] = Math.min(dp[i][j - 1] + 1, dp[i - 1][j] + 1); 
                }
            }
        }
        return dp[len1][len2];
    }
}
```

- 时间复杂度: O(n * m)
- 空间复杂度: O(n * m)

 