![[Pasted image 20240508131257.png]]

### 动态规划

动规五部曲分析如下：

1. 确定dp数组（dp table）以及下标的含义

**`dp[i]`：以下标i为结尾的连续递增的子序列长度为`dp[i]`**。


2. 确定递推公式

如果 `nums[i] > nums[i - 1]`，那么以 i 为结尾的连续递增的子序列长度一定等于以i - 1为结尾的连续递增的子序列长度 + 1 。即：`dp[i] = dp[i - 1] + 1;`

**注意这里就体现出和[[最长递增子序列]]的区别！**

因为本题要求连续递增子序列，所以就只要比较`nums[i]`与`nums[i - 1]`。

3. dp数组如何初始化

`dp[i]`应该初始1。

4. 确定遍历顺序

一定是从前向后遍历。

5. 举例推导dp数组

已输入nums = `[1,3,5,4,7]`为例，dp数组状态如下，**注意这里要取`dp[i]`里的最大值，所以`dp[2]`才是结果！**

![674.最长连续递增序列|475](https://code-thinking-1253855093.file.myqcloud.com/pics/20210204103529742.jpg)

#### 整体代码

```java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        int len = nums.length;
        int res = 1;
        int[] dp = new int[len];
        Arrays.fill(dp, 1);
        for (int i = 1; i < len; i++) {
            if (nums[i - 1] < nums[i]) { // 比较自己和前一个大小就行！
                dp[i] = Math.max(dp[i], dp[i - 1] + 1);
            }
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

### 贪心算法

```java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        int res = 1;
        int count = 1;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i - 1] < nums[i]) { 
                count++;
            }
            else{  // 不连续，count从头开始
                count = 1;
            }
            res = Math.max(res, count);
        }
        return res;
    }
}
```
