![[Pasted image 20240423184813.png|650]]

### 贪心算法

这道题之前在讲解贪心专题的时候解决过一次，见[[数据结构与算法/贪心算法/最大子数组和#动态规划|最大子数组和]]。

### 动态规划

动规五部曲如下：

1. 确定dp数组（dp table）以及下标的含义

**`dp[i]`：包括下标 i（以`nums[i]`为结尾）的最大连续子序列和为`dp[i]`**。

2. 确定递推公式

`dp[i]`只有两个方向可以推出来：

- `dp[i - 1] + nums[i]`，即：`nums[i]`加入当前连续子序列和
- `nums[i]`，即：从头开始计算当前连续子序列和

一定是取最大的，所以 **`dp[i] = max(dp[i - 1] + nums[i], nums[i]);`**

3. dp数组如何初始化

很明显`dp[0] = nums[0]`。

4. 确定遍历顺序

递推公式中`dp[i]`依赖于`dp[i - 1]`的状态，需要从前向后遍历。

5. 举例推导dp数组

以示例一为例，输入：nums = `[-2,1,-3,4,-1,2,1,-5,4]`，对应的dp状态如下： 

![53.最大子序和（动态规划）|525](https://code-thinking-1253855093.file.myqcloud.com/pics/20210303104129101.png)

**注意最后的结果可不是`dp[nums.size() - 1]`** ，而是`dp[6]`。

在回顾一下`dp[i]`的定义：包括下标i之前的最大连续子序列和为`dp[i]`。那么我们要找最大的连续子序列，就应该找每一个i为终点的连续最大子序列。

所以在递推公式的时候，可以直接选出最大的`dp[i]`。

#### 整体代码

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int len = nums.length;
        int[] dp = new int[len];
        dp[0] = nums[0];
        int res = nums[0];
        for(int i = 1; i < len; i++){
            dp[i] = Math.max(nums[i], dp[i - 1] + nums[i]);
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

因为`dp[i]`的递推公式只与前一个值有关，所以可以用一个变量代替dp数组来优化空间：

```java
//因为dp[i]的递推公式只与前一个值有关，所以可以用一个变量代替dp数组，空间复杂度为O(1)
class Solution {
    public int maxSubArray(int[] nums) {
        int res = nums[0];
        int pre = nums[0];
        for(int i = 1; i < nums.length; i++) {
            pre = Math.max(nums[i], pre + nums[i]);
            res = Math.max(res, pre);
        }
        return res;
    }
}
```