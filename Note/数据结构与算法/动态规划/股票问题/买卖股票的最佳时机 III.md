![[Pasted image 20240506200506.png|475]]
![[Pasted image 20240506200523.png|650]]

## 思路

这道题目相对[[买卖股票的最佳时机]]和[[数据结构与算法/动态规划/股票问题/买卖股票的最佳时机 II|买卖股票的最佳时机 II]]难了不少。

关键在于至多买卖两次，这意味着可以买卖一次，可以买卖两次，也可以不买卖。

### 动态规划

1. 确定dp数组以及下标的含义

一天一共就有五个状态，

0. 没有操作 （其实我们也可以不设置这个状态）
1. 第一次持有股票
2. 第一次不持有股票
3. 第二次持有股票
4. 第二次不持有股票

`dp[i][j]`中 i 表示第 i 天，j为 `[0 - 4]` 五个状态，**`dp[i][j]`表示第 i 天状态 j 所剩最大现金**。

需要注意：`dp[i][1]`，**表示的是第i天，持有股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区**。

2. 确定递推公式

达到`dp[i][1]`状态，有两个具体操作：

- 操作一：第i天买入股票了，那么`dp[i][1] = dp[i-1][0] - prices[i]`
- 操作二：第i天没有操作，而是沿用前一天买入的状态，即：`dp[i][1] = dp[i - 1][1]`

 `dp[i][1]`一定是选最大的，所以 `dp[i][1] = max(dp[i-1][0] - prices[i], dp[i - 1][1]);`

同理`dp[i][2]`也有两个操作：

- 操作一：第i天卖出股票了，那么`dp[i][2] = dp[i - 1][1] + prices[i]`
- 操作二：第i天没有操作，沿用前一天卖出股票的状态，即：`dp[i][2] = dp[i - 1][2]`

所以`dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])`

同理可推出剩下状态部分：
`dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);` 
`dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);

3. dp数组如何初始化

第0天没有操作，这个最容易想到，就是0，即：`dp[0][0] = 0;`

第0天做第一次买入的操作，`dp[0][1] = -prices[0];`

第0天做第一次卖出的操作，可以理解当天买入，当天卖出，所以`dp[0][2] = 0;`

第0天第二次买入操作，其实相当于第0天第一次买入了，第一次卖出了，然后再买入一次（第二次买入）。所以第二次买入操作，初始化为：`dp[0][3] = -prices[0];`

同理第二次卖出初始化`dp[0][4] = 0;`

4. 确定遍历顺序

从递归公式其实已经可以看出，一定是从前向后遍历。

5. 举例推导dp数组

以输入`[1,2,3,4,5]`为例

![123.买卖股票的最佳时机III|475](https://code-thinking-1253855093.file.myqcloud.com/pics/20201228181724295-20230310134201291.png)

大家可以看到红色框为最后两次卖出的状态。

现在最大的时候一定是卖出的状态，而两次卖出的状态现金最大一定是最后一次卖出。也可以这么理解：如果第一次卖出已经是最大值了，那么我们可以在当天立刻买入再立刻卖出。所以`dp[4][4]`已经包含了`dp[4][2]`的情况。也就是说第二次卖出手里所剩的钱一定是最多的。所以最终最大利润是`dp[4][4]`。

#### 整体代码

这里我没有设置`dp[i][0]`这个状态，所以0~4的5个状态就简化成了0~3的4个状态：

```java
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        if(len == 1){
            return 0;
        }
        //0:第一次持有，1:第一次不持有(卖出)，2:第二次持有，3:第二次不持有(卖出)
        int[][] dp = new int[len][4];
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        dp[0][2] = -prices[0]; // 可以理解成当天买入又卖出再买入
        dp[0][3] = 0;
        for(int i = 1; i < len; i++){
            dp[i][0] = Math.max(dp[i - 1][0], - prices[i]); //第一次持有前一定是0
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
            dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] - prices[i]);
            dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] + prices[i]);
        }
        return dp[len - 1][3];
    }
}
```

由于`dp[i][j]`都是由`dp[i - 1][j]`推出的，故可以压缩成一维数组：

```java
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        // if(len == 1){ // 可以省略
        //     return 0;
        // }
        //0:第一次持有，1:第一次不持有(卖出)，2:第二次持有，3:第二次不持有(卖出)
        int[] dp = new int[4];
        dp[0] = -prices[0];
        dp[2] = -prices[0]; // 可以理解成当天买入又卖出再买入
        for(int i = 1; i < len; i++){
            dp[0] = Math.max(dp[0], - prices[i]); //第一次持有前一定是0
            dp[1] = Math.max(dp[1], dp[0] + prices[i]);
            dp[2] = Math.max(dp[2], dp[1] - prices[i]);
            dp[3] = Math.max(dp[3], dp[2] + prices[i]);
        }
        return dp[3];
    }
}
```
