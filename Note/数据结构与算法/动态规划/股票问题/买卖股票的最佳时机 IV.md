![[Pasted image 20240506212959.png|650]]

## 思路

这道题目可以说是[[买卖股票的最佳时机 III]]的进阶版，这里要求至多有k次交易。

1. 确定dp数组以及下标的含义

本题其实依然可以用一个二维dp数组。使用二维数组 `dp[i][j]` ：第i天的状态为j，所剩下的最大现金是`dp[i][j]`

j 的状态表示为：

- 0 表示不操作
- 1 第一次买入
- 2 第一次卖出
- 3 第二次买入
- 4 第二次卖出
- .....

**大家应该发现规律了吧 ，除了0以外，偶数就是卖出，奇数就是买入**。

题目要求是至多有K笔交易，那么j的范围就定义为 2 * k + 1 就可以了。所以二维dp数组定义为：

```java
int[][] dp = new int[prices.length][2 * k + 1];
```


2. 确定递推公式

和上一道题一样， 0：没有操作, 1：第一次持有, 2：第一次不持有(卖出), 3：第二次持有, 4：第二次不持有。

则`dp[i][1]`和`dp[i][2]`公式如下：
`dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][1]);`
`dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])`

同理可以类比剩下的状态，**用 j 来表示状态**，代码如下：

```java
for(int j = 0; j < 2 * k; j += 2){ //j 代表每一次的交易，j每次要跳跃2
    dp[i][j + 1] = Math.max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
    dp[i][j + 2] = Math.max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
}
```

**本题和[[买卖股票的最佳时机 III]]最大的区别就是这里要类比 j 为奇数是买，偶数是卖的状态**。

3. dp数组如何初始化

**同理可以类比推出`dp[0][j]`当 j 为奇数的时候都初始化为 `-prices[0]`**：

```java
for(int i = 1; i < 2 * k; i += 2){
    dp[0][i] = -prices[0]; // 所有持有时的初始状态都设成-prices[0]
}
```

4. 确定遍历顺序

从递归公式其实已经可以看出，一定是从前向后遍历。

5. 举例推导dp数组

以输入`[1,2,3,4,5]`，k=2为例。最后一次卖出，一定是利润最大的，即红色部分就是最后求解。

![188.买卖股票的最佳时机IV|500](https://code-thinking-1253855093.file.myqcloud.com/pics/20201229100358221.png)

#### 整体代码

这里就不用[[买卖股票的最佳时机 III#整体代码]]这里的4个状态了，因为有数组越界的因素，还是用0~4的5个状态，其中状态0是无状态，但是会在循环中用到。

当k为2时如下：

```java
        /* 定义 5 种状态:
         * 0: 没有操作, 1: 第一次持有, 2: 第一次不持有(卖出), 3: 第二次持有, 4: 第二次不持有 */
        int[][] dp = new int[len][5];
        dp[0][1] = -prices[0];
        // 初始化第二次买入的状态是确保 最后结果是最多两次买卖的最大利润
        dp[0][3] = -prices[0];

        for (int i = 1; i < len; i++) {
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }
```

归纳得以下代码：

```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        int len = prices.length;
        // if(len == 1){
        //     return 0;
        // }
        // 0:无状态，1/3/5...奇数:第1/2/3...次持有，2/4...偶数:第1/2/3...次不持有(卖出)
        int[][] dp = new int[len][2 * k + 1];
        for(int i = 1; i < 2 * k; i += 2){
            dp[0][i] = -prices[0]; // 所有持有时的初始状态都设成-prices[0]
        }
        for(int i = 1; i < len; i++){ 
            for(int j = 0; j < 2 * k; j += 2){ //j代表每一次的交易，j每次要跳跃2
                dp[i][j + 1] = Math.max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
                dp[i][j + 2] = Math.max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
            }
        }
        return dp[len - 1][2 * k];
    }
}
```
