![[Pasted image 20240508081629.png|650]]

## 思路

本题贪心解法：[贪心算法：买卖股票的最佳时机含手续费(opens new window)](https://programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.html)

性能是：

- 时间复杂度：O(n)
- 空间复杂度：O(1)

本题使用贪心算法并不好理解，也很容易出错，那么我们再来看看是使用动规的方法如何解题。

相对于[[数据结构与算法/动态规划/股票问题/买卖股票的最佳时机 II|买卖股票的最佳时机 II]]，本题只需要在计算卖出操作的时候减去手续费就可以了，代码几乎是一样的。`dp[i][0]` 表示第i天持有股票所省最多现金。 `dp[i][1]` 表示第i天不持有股票所得最多现金。

`dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);`和之前一样。

`dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);`

**本题和[[数据结构与算法/动态规划/股票问题/买卖股票的最佳时机 II|买卖股票的最佳时机 II]]的区别就是这里需要多一个减去手续费的操作**。

#### 整体代码

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int len = prices.length;
        int[][] dp = new int[len][2]; // 0：已经持有股票(可能会买入)，1：不持有(可能卖了)
        dp[0][0] = -prices[0];
        for (int i = 1; i < len; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]); //唯一不同的地方
            dp[i][1] = Math.max(dp[i - 1][0] + prices[i] - fee, dp[i - 1][1]);
        }
        return dp[len - 1][1];
    }
}
```

- 时间复杂度：O(n)
- 空间复杂度：O(n)