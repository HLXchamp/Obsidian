![[Pasted image 20240506170833.png|675]]

## 思路

### 暴力算法（双指针）

这道题目最直观的想法，就是暴力，找最优间距了。

```java
class Solution {
    public int maxProfit(int[] prices) {
        int result = 0;
        for (int i = 0; i < prices.length; i++) {
            for (int j = i + 1; j < prices.length; j++) {
                result = Math.max(result, prices[j] - prices[i]);
            }
        }
        return result;
    }
}
```

- 时间复杂度：O(n^2)
- 空间复杂度：O(1)

当然该方法超时了：

![[Pasted image 20240506171216.png]]

### 贪心

因为股票就**买卖一次**，那么贪心的想法很自然就是**取最左最小值**，**取最右最大值**，那么得到的差值就是最大利润。

#### 整体代码

```java
class Solution {
    public int maxProfit(int[] prices) {
        int low = Integer.MAX_VALUE;
        int result = 0;
        for (int i = 0; i < prices.length; i++) {
            low = Math.min(low, prices[i]);  // 取最左最小价格
            result = Math.max(result, prices[i] - low); // 直接取最大区间利润
        }
        return result;
    }
}
```

- 时间复杂度：O(n)
- 空间复杂度：O(1)

### 动态规划

动规五部曲分析如下：

1. 确定dp数组（dp table）以及下标的含义

`dp[i][0]` 表示第i天**持有股票**所得最多现金 ，**这里可能有同学疑惑，本题中只能买卖一次，持有股票之后哪还有现金呢？** 其实一开始现金是0，那么加入第i天买入股票现金就是 `-prices[i]`， 这是一个负数。

`dp[i][1]` 表示第i天**不持有股票**所得最多现金。**注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态**

2. 确定递推公式

如果第i天持有股票即`dp[i][0]`， 那么可以由两个状态推出来：

- 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即`dp[i - 1][0]`
- 第i天买入股票，所得现金就是买入今天的股票后所得现金即：`-prices[i]`

那么`dp[i][0]`应该选所得现金最大的，所以 **`dp[i][0] = max(dp[i - 1][0], -prices[i]);`**

如果第i天不持有股票即`dp[i][1]`， 也可以由两个状态推出来：

- 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即`dp[i - 1][1]`
- 第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：`prices[i] + dp[i - 1][0]`

同样`dp[i][1]`取最大的，**`dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);`****

3. dp数组如何初始化

由递推公式可以看出，其基础都是要从`dp[0][0]`和`dp[0][1]`推导出来。

那么`dp[0][0]`表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能有前一天推出来，所以`dp[0][0] -= prices[0];`

`dp[0][1]`表示第0天不持有股票，不持有股票那么现金就是0，所以`dp[0][1] = 0;`

4. 确定遍历顺序

从递推公式可以看出一定是从前向后遍历的。

5. 举例推导dp数组

以示例1，输入：`[7,1,5,3,6,4]`为例，dp数组状态如下：

![121.买卖股票的最佳时机|400](https://code-thinking-1253855093.file.myqcloud.com/pics/20210224225642465.png)

`dp[5][1]`就是最终结果。为什么不是`dp[5][0]`呢？ **因为本题中不持有股票状态所得金钱一定比持有股票状态得到的多！**

#### 整体代码

普通形式：

```java
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        int[][] dp = new int[len][2]; // 0：已经持有股票(可能会买入)，1：不持有(可能卖了)
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);
            dp[i][1] = Math.max(dp[i - 1][0] + prices[i], dp[i - 1][1]);
        }
        return dp[len - 1][1];
    }
}
```

观察得出`dp[i]`只是依赖于`dp[i - 1]`的状态，那么只需要记录当前天的dp状态和前一天的dp状态就可以了，可以使用滚动数组来节省空间：

把dp数组中的`i`改成`i % 2`，`i - 1`改成`(i - 1) % 2`即可：

```java
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        int[][] dp = new int[2][2]; // 0：已经持有股票(可能会买入)，1：不持有(可能卖了)
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i % 2][0] = Math.max(dp[(i - 1) % 2][0], -prices[i]);
            dp[i % 2][1] = Math.max(dp[(i - 1) % 2][0] + prices[i], dp[(i - 1) % 2][1]);
        }
        return dp[(len - 1) % 2][1];
    }
}
```
