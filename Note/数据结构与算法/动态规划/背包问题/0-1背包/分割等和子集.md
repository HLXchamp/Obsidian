![[Pasted image 20240430105837.png|650]]

## 思路

这道题目初步看，和如下两题几乎是一样的，大家可以用回溯法，解决如下两题

- 698.划分为k个相等的子集
- 473.火柴拼正方形

这道题目是要找是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。那么只要找到集合里能够出现 sum / 2 的子集总和，就算是可以分割成两个相同元素和子集了。

本题是可以用回溯暴力搜索出所有答案的，但最后超时了，也不想再优化了，放弃回溯，直接上01背包吧。

### 0-1背包问题

背包问题，大家都知道，有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是`weight[i]`，得到的价值是`value[i]` 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。

**背包问题有多种背包方式，常见的有：01背包、完全背包、多重背包、分组背包和混合背包等等。** 要注意题目描述中商品是不是可以重复放入。**要明确本题中我们要使用的是01背包，因为元素我们只能用一次。**

**只有确定了如下四点，才能把01背包问题套到本题上来。**

- 背包的体积为sum / 2
- 背包要放入的商品（集合里的元素）**重量为 元素的数值，价值也为元素的数值**
- 背包如果正好装满，说明找到了总和为 sum / 2 的子集。
- 背包中每一个元素是不可重复放入。

以上分析完，我们就可以套用01背包，来解决这个问题了。

#### 动规五部曲

1. 确定dp数组以及下标的含义

**`dp[j]`表示 背包总容量（所能装的总重量）是j，放进物品后，背的最大重量为`dp[j]`**。

那么如果背包容量为target， `dp[target]`就是装满 背包之后的重量，所以 当 `dp[target] == target` 的时候，背包就装满了。

那还有装不满的时候？

拿输入数组 `[1, 5, 11, 5]`举例， `dp[7]` 只能等于 6，没装满，因为只能放进 1 和 5。而`dp[6]` 就可以等于6了，放进1 和 5，那么`dp[6] == 6`，说明背包装满了。

2. 确定递推公式

0-1背包的递推公式为：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);`

本题，相当于背包里放入数值，那么**物品i的重量是`nums[i]`，其价值也是`nums[i]`**。

所以递推公式：`dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);`

3. dp数组如何初始化

从`dp[j]`的定义来看，首先`dp[0]`一定是0。本题题目中只包含正整数的非空数组，所以非0下标的元素初始化为0就可以了。

4. 确定遍历顺序

如果使用一维dp数组，**物品遍历的for循环放在外层**，遍历**背包的for循环放在内层**，且内层for循环**倒序遍历**！

5. 举例推导dp数组

`dp[j]`的数值一定是小于等于j的。

**如果`dp[j] == j` 说明，集合中的子集总和正好可以凑成总和j，理解这一点很重要。**

用例1，输入`[1,5,11,5]` 为例，如图：

![416.分割等和子集2](https://code-thinking-1253855093.file.myqcloud.com/pics/20210110104240545.png)

最后`dp[11] == 11`，说明可以将这个数组分割成两个子集，使得两个子集的元素和相等。

#### 整体代码

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for(int t : nums){
            sum += t;
        }
        if(sum % 2 != 0){
            return false;
        }
        int target = sum / 2;
        int[] dp = new int[target + 1];
        for(int i = 0; i < nums.length; i++){ // 先遍历物品
            for(int j = target; j >= nums[i]; j--){ // j >= nums[i]
                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
                //剪枝一下，每一次完成内层循环，立即检查是否dp[target] == target
                if(dp[target] == target) return true;
            }
        }
        return dp[target] == target;
    }
}
```
