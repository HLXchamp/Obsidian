## 思路

对于面试的话，其实掌握01背包，和完全背包，就够用了，最多可以再来一个多重背包。这几种背包，如下：

![416.分割等和子集1|775](https://code-thinking-1253855093.file.myqcloud.com/pics/20210117171307407.png)

而完全背包又是也是01背包稍作变化而来，即：完全背包的物品数量是无限的。

**所以背包问题的理论基础重中之重是01背包，一定要理解透！**

#### 0-1 背包

有n件物品和一个最多能背重量为w的背包。第i件物品的重量是`weight[i]`，得到的价值是`value[i]` 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

![动态规划-背包问题|400](https://code-thinking-1253855093.file.myqcloud.com/pics/20210117175428387.jpg)

这是标准的背包问题，每一件物品其实只有两个状态，取或者不取，所以暴力的解法可以使用**回溯法**搜索出所有的情况，那么时间复杂度就是$o(2^n)$，这里的n表示物品数量。

**所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！**

在下面的讲解中举一个例子：背包最大重量为4。物品见下表，问背包能背的物品最大价值是多少？

||重量|价值|
|---|---|---|
|物品0|1|15|
|物品1|3|20|
|物品2|4|30|

#### 二维dp数组0-1背包

1. 确定dp数组以及下标的含义

对于背包问题，有一种写法， 是使用二维数组，即 **`dp[i][j]` 表示从下标为`[0-i]`的物品里任意取，放进容量为j的背包，价值总和最大是多少**。

只看这个二维数组的定义，大家一定会有点懵，看下面这个图：

![动态规划-背包问题1|500](https://code-thinking-1253855093.file.myqcloud.com/pics/20210110103003361.png)

**要时刻记着这个dp数组的含义，下面的一些步骤都围绕这dp数组的含义进行的**，如果哪里看懵了，就来回顾一下i代表什么，j又代表什么。

2. 确定递推公式

再回顾一下`dp[i][j]`的含义：从下标为`[0-i]`的物品里任意取，放进容量为j的背包，价值总和最大是多少。

那么可以有两个方向推出来`dp[i][j]`，

- **不放物品i**：由`dp[i - 1][j]`推出，即背包容量为j，里面不放物品i的最大价值，此时`dp[i][j]`就是`dp[i - 1][j]`(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同)；
- **放物品i**：由`dp[i - 1][j - weight[i]]`推出，`dp[i - 1][j - weight[i]]` 为背包容量为`j - weight[i]`的时候不放物品i的最大价值（因为要放物品 i 就要为它挪位子，剩下的容量就是`j - weight[i]`了），那么`dp[i - 1][j - weight[i]] + value[i]` （物品i的价值），就是背包放物品i得到的最大价值。

所以递归公式： `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);`

3. dp数组如何初始化

**关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱**。

首先从`dp[i][j]`的定义出发，如果背包容量j为0的话，即`dp[i][0]`，无论是选取哪些物品，背包价值总和一定为0。如图：

![动态规划-背包问题2|500](https://code-thinking-1253855093.file.myqcloud.com/pics/2021011010304192.png)

状态转移方程 `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);` 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。

`dp[0][j]`，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。

那么很明显当 `j < weight[0]`的时候，`dp[0][j]` 应该是 0，因为背包容量比编号0的物品重量还小。当`j >= weight[0]`时，`dp[0][j]` 应该是`value[0]`，因为背包容量放足够放编号0物品。

![动态规划-背包问题7|500](https://code-thinking-1253855093.file.myqcloud.com/pics/20210110103109140.png)

其他下标初始为什么数值都可以，因为都会被覆盖。但只不过一开始就统一把dp数组统一初始为0，更方便一些。

![动态规划-背包问题10|500](https://code-thinking-1253855093.file.myqcloud.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%9810.jpg)

最后初始化代码如下：

```java
int[][] dp = new int[weight.length][bagweight + 1];
// 初始化第一行
for (int j = weight[0]; j <= bagweight; j++) {
    dp[0][j] = value[0];
}
```

4. 确定遍历顺序

在如下图中，可以看出，有两个遍历的维度：物品与背包重量

![动态规划-背包问题3|475](https://code-thinking-1253855093.file.myqcloud.com/pics/2021011010314055.png)

那么问题来了，**先遍历 物品还是先遍历背包重量呢？** **其实都可以！！ 但是先遍历物品更好理解**。

先遍历物品，然后遍历背包重量的代码：

```java
// weight数组的大小 就是物品个数
for(int i = 1; i < weight.length; i++) { // 遍历物品
    for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
        if (j < weight[i]) dp[i][j] = dp[i - 1][j];
        else dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
    }
}
```

递归公式中可以看出`dp[i][j]`是靠`dp[i-1][j]`和`dp[i - 1][j - weight[i]]`推导出来的。`dp[i-1][j]`和`dp[i - 1][j - weight[i]]` 都在`dp[i][j]`的左上角方向（包括正上方向），那么先遍历物品，再遍历背包的过程如图所示：

![动态规划-背包问题5|500](https://code-thinking-1253855093.file.myqcloud.com/pics/202101101032124.png)

5. 举例推导dp数组

来看一下对应的dp数组的数值，如图：

![动态规划-背包问题4|500](https://code-thinking-1253855093.file.myqcloud.com/pics/20210118163425129.jpg)

最终结果就是`dp[2][4]`。

#### 整体代码

```java
public class BagProblem {
    public static void main(String[] args) {
        int[] weight = {1,3,4};
        int[] value = {15,20,30};
        int bagSize = 4;
        testWeightBagProblem(weight,value,bagSize);
    }

    public static void testWeightBagProblem(int[] weight, int[] value, int bagSize){
        int goods = weight.length;  // 获取物品的数量，行
        int[][] dp = new int[goods][bagSize + 1];

        // 初始化dp数组
        // 创建数组后，其中默认的值就是0
        for (int j = weight[0]; j <= bagSize; j++) {
            dp[0][j] = value[0];
        }

        // 填充dp数组
        for (int i = 1; i < weight.length; i++) {
            for (int j = 1; j <= bagSize; j++) {
                if (j < weight[i]) {
                    /**
                     * 当前背包的容量都没有当前物品i大的时候，是不放物品i的
                     * 那么前i-1个物品能放下的最大价值就是当前情况的最大价值
                     */
                    dp[i][j] = dp[i-1][j];
                } else {
                    /**
                     * 当前背包的容量可以放下物品i
                     * 那么此时分两种情况：
                     *    1、不放物品i
                     *    2、放物品i
                     * 比较这两种情况下，哪种背包中物品的最大价值最大
                     */
                    dp[i][j] = Math.max(dp[i-1][j] , dp[i-1][j-weight[i]] + value[i]);
                }
            }
        }

        // 打印dp数组
        for (int i = 0; i < goods; i++) {
            for (int j = 0; j <= bagSize; j++) {
                System.out.print(dp[i][j] + "\t");
            }
            System.out.println("\n");
        }
    }
}
```