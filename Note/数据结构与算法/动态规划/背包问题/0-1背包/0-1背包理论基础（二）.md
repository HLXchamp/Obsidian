## 思路

[[0-1背包理论基础（一）]]中是用二维dp数组来讲解01背包。现在就来说一说**滚动数组**，其实在前面的题目中已经用到过滚动数组了，就是把二维dp降为一维dp。

接下来还是用如下这个例子来进行讲解。背包最大重量为4。物品如下表，问背包能背的物品最大价值是多少？

||重量|价值|
|---|---|---|
|物品0|1|15|
|物品1|3|20|
|物品2|4|30|

### 一维dp数组（滚动数组）

对于背包问题其实状态都是可以压缩的。

在使用二维数组的时候，递推公式：`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);`

**其实可以发现如果把`dp[i - 1]`那一层拷贝到`dp[i]`上，表达式完全可以是：`dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);`**

**与其把`dp[i - 1]`这一层拷贝到`dp[i]`上，不如只用一个一维数组了**，只用`dp[j]`（一维数组，也可以理解是一个滚动数组）。

#### 动规五部曲

1. 确定dp数组的定义

在一维dp数组中，`dp[j]`表示：容量为j的背包，所背的物品最大价值。

2. 一维dp数组的递推公式

`dp[j]`可以通过`dp[j - weight[i]]`推导出来，`dp[j - weight[i]]`表示容量为`j - weight[i]`的背包所背的最大价值。

`dp[j - weight[i]] + value[i]` 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：`dp[j]`）

此时`dp[j]`有两个选择，一个是取自己`dp[j]` 相当于 二维dp数组中的`dp[i-1][j]`，即不放物品i，一个是取`dp[j - weight[i]] + value[i]`，即放物品i，指定是取最大的，毕竟是求最大价值，

所以递归公式为：

```java
dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
```

可以看出相对于二维dp数组的写法，就是把`dp[i][j]`中i的维度去掉了。

3. 一维dp数组如何初始化

**关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱**。

`dp[j]`表示：容量为j的背包，所背的物品价值可以最大为`dp[j]`，那么`dp[0]`就应该是0，因为背包容量为0所背的物品的最大价值就是0。

那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？假设物品价值都是大于0的，都初始为0就可以了。

4. 一维dp数组遍历顺序

代码如下：

```java
for(int i = 0; i < weight.length; i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```

**这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！** 一维dp遍历的时候，背包是从大到小**倒序遍历**。 ^1975e7

**倒序遍历是为了保证物品i只被放入一次！**。但如果一旦正序遍历了，那么物品0就会被重复加入多次！举一个例子：物品0的重量`weight[0] = 1`，价值`value[0] = 15`：

如果正序遍历：

`dp[1] = dp[1 - weight[0]] + value[0] = 15`， `dp[2] = dp[2 - weight[0]] + value[0] = 30`

此时`dp[2]`就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。

倒序就是先算`dp[2]`：

`dp[2] = dp[2 - weight[0]] + value[0] = 15` （dp数组已经都初始化为0），`dp[1] = dp[1 - weight[0]] + value[0] = 15`

所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。

5. 举例推导dp数组

一维dp，分别用物品0，物品1，物品2 来遍历背包，最终得到结果如下：

![动态规划-背包问题9|500](https://code-thinking-1253855093.file.myqcloud.com/pics/20210110103614769.png)

#### 整体代码

```java
public static void main(String[] args) {
        int[] weight = {1, 3, 4};
        int[] value = {15, 20, 30};
        int bagWight = 4;
        testWeightBagProblem(weight, value, bagWight);
    }

    public static void testWeightBagProblem(int[] weight, int[] value, int bagWeight){
        int wLen = weight.length;
        //定义dp数组：dp[j]表示背包容量为j时，能获得的最大价值
        int[] dp = new int[bagWeight + 1];
        //遍历顺序：先遍历物品，再遍历背包容量
        for (int i = 0; i < wLen; i++){
            for (int j = bagWeight; j >= weight[i]; j--){
                dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
            }
        }
        //打印dp数组
        for (int j = 0; j <= bagWeight; j++){
            System.out.print(dp[j] + " ");
        }
    }
```