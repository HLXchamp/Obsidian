![[Pasted image 20240501152953.png|675]]

## 思路

其实本题并不是多重背包，再来看一下这个图，捋清几种背包的关系：

![416.分割等和子集1](https://code-thinking-1253855093.file.myqcloud.com/pics/20210117171307407-20230310132423205.png)

多重背包是每个物品，数量不同的情况。

**本题中strs 数组里的元素就是物品，每个物品都是一个！** **而m和n相当于是一个背包，两个维度的背包**。

理解成多重背包的同学主要是把m和n混淆为物品了，感觉这是不同数量的物品，所以以为是多重背包。但本题其实是0-1背包问题！只不过这个**背包有两个维度**，一个是m 一个是n，而不同长度的字符串就是不同大小的待装物品。

#### 动规五部曲

1. 确定dp数组（dp table）以及下标的含义

**`dp[i][j]`：最多有i个0和j个1的strs的最大子集的大小为`dp[i][j]`**。

2. 确定递推公式

`dp[i][j]` 可以由前一个strs里的字符串推导出来，假设strs里的字符串有x个0，y个1。

`dp[i][j]` 就可以是 `dp[i - x][j - y] + 1`。然后我们在遍历的过程中，取`dp[i][j]`的最大值。所以**递推公式：`dp[i][j] = max(dp[i][j], dp[i - x][j - y] + 1)`。**

此时大家可以回想一下01背包的递推公式：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`，

对比一下就会发现，字符串的x和y相当于物品的重量（`weight[i]`），字符串本身的个数相当于物品的价值（`value[i]`）。

**这就是一个典型的01背包！** 只不过物品的重量有了两个维度而已。

3. dp数组如何初始化

m = n = 0时，最大子集肯定是0，故`dp[i][j] = 0`，其他元素默认为0即可。

4. 确定遍历顺序

一定是**外层for循环遍历物品**，**内层for循环遍历背包**容量且从后向前遍历！

那么本题也是，物品就是strs里的字符串，背包容量就是题目描述中的m和n。

5. 举例推导dp数组

以输入：`["10","0001","111001","1","0"]`，m = 3，n = 3为例

最后dp数组的状态如下所示：

![[Pasted image 20240502164624.png|600]]

#### 整体代码

```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int[][] dp = new int[m + 1][n + 1];
        dp[0][0] = 0;
        for(String s : strs){
            int x = 0; // 不能定义在for外面，因为每遍历一个元素都是从x=y=0开始的
            int y = 0;
            for(int i = 0; i < s.length(); i++){
                if(s.charAt(i) == '0'){
                    x++;
                }
                if(s.charAt(i) == '1'){
                    y++;
                }
            }
            // for(char i : s.toCharArray()){ // 也可以转化成字符数组再遍历
            //     if(i == '0'){
            //         x++;
            //     }
            //     if(i == '1'){
            //         y++;
            //     }
            // }
            for(int i = m; i >= x; i--){
                for(int j = n; j >= y; j--){
                    dp[i][j] = Math.max(dp[i][j], dp[i - x][j - y] + 1);
                }
            }
        }
        return dp[m][n];
    }
}
```
