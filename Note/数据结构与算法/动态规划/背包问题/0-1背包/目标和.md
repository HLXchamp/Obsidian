![[Pasted image 20240430231011.png|650]]

**提示：**
- `1 <= nums.length <= 20`
- `0 <= nums[i] <= 1000`
- `0 <= sum(nums[i]) <= 1000`
- `-1000 <= target <= 1000`

## 思路

这道题目咋眼一看和动态规划背包啥的也没啥关系。

本题要如何使表达式结果为target，既然为target，那么就一定有 left组合 - right组合 = target。又因为left + right = sum，而sum是固定的。就可以推导出 **`left = (target + sum)/2`** 。

target和sum是固定的，left就可以求出来。问题就转化为**在nums中找出和为left的组合**。

### 回溯算法

这道题可以套回溯算法中[[组合总和]]的回溯法代码，几乎不用改动，将本题转变为**组合总和问题**。当然，也可以转变成序列区间选+ 或者 -，使用回溯法，那就是另一个解法。但使用回溯法时间复杂度很高，容易超时！

#### 整体代码

```java
class Solution {
    // List<List<Integer>> result;
    int res = 0;
    List<Integer> path = new ArrayList<>();

    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for (int num : nums) sum += num;
        if (target > sum) return 0;
        if ((target + sum) % 2 == 1) return 0;
        int bagSize = (target + sum) / 2; // 转变为组合总和问题，bagsize就是要求的和

        // result = new ArrayList<>();
        Arrays.sort(nums); // 需要排序
        backtracking(nums, bagSize, 0, 0);
        // return result.size();
        return res;
    }
    
    public void backtracking(int[] candidates, int target, int sum, int startIndex) {
        if (sum == target) {
            // result.add(new ArrayList<>(path));
            res++;
        }
        for (int i = startIndex; i < candidates.length && sum + candidates[i] <= target; i++) {
            sum += candidates[i];
            path.add(candidates[i]);
            backtracking(candidates, target, sum, i + 1);
            sum -= candidates[i];
            path.remove(path.size() - 1);
        }
    }
}
```

### 动态规划

**问题就转化为，装满容量为x的背包，有几种方法**。这里的x，就是bagSize，也就是我们后面要求的背包容量。

如果`(target + sum) / 2 != 0`，则是无解的，例如sum 是5，S（target）是2的话其实就是无解的；同时如果 S的绝对值已经大于sum，那么也是没有方案的。

再回归到01背包问题，为什么是0-1背包呢？因为每个物品（题目中的1）只用一次！这次和之前遇到的背包问题不一样了，之前都是求容量为j的背包，最多能装多少。本题则是装满有几种方法。其实这就是一个组合问题了。

1. 确定dp数组以及下标的含义

`dp[j]` 表示：**填满 j（包括j）这么大容积的包，有`dp[j]`种方法！**

其实也可以使用二维dp数组来求解本题，`dp[i][j]`：使用 下标为`[0, i]`的`nums[i]`能够凑满j（包括j）这么大容量的包，有`dp[i][j]`种方法。

2. 确定递推公式

只要搞到`nums[i]`，凑成`dp[j]`就有`dp[j - nums[i]]` 种方法。

例如：`dp[j]`，j 为5，

- 已经有一个1（`nums[i]`） 的话，有 `dp[4]`种方法 凑成 容量为5的背包。
- 已经有一个2（`nums[i]`） 的话，有 `dp[3]`种方法 凑成 容量为5的背包。
- 已经有一个3（`nums[i]`） 的话，有 `dp[2]`中方法 凑成 容量为5的背包
- 已经有一个4（`nums[i]`） 的话，有 `dp[1]`中方法 凑成 容量为5的背包
- 已经有一个5 （`nums[i]`）的话，有 `dp[0]`中方法 凑成 容量为5的背包

那么凑整`dp[5]`有多少方法呢，也就是把 所有的 `dp[j - nums[i]]` 累加起来。

所以求组合类问题的公式，都是类似这种：

```java
dp[j] += dp[j - nums[i]]
```

**这个公式在后面在讲解背包解决排列组合问题的时候还会用到！**

3. dp数组如何初始化

如果数组`[0]` ，target = 0，那么 bagSize = (target + sum) / 2 = 0。 `dp[0]`也应该是1， 也就是说给数组里的元素 0 前面无论放加法还是减法，都是 1 种方法。

所以应该初始化 `dp[0] = 1`。

`dp[j]`其他下标对应的数值应该初始化为0，从递推公式也可以看出，`dp[j]`要保证是0的初始值，才能正确的由`dp[j - nums[i]]`推导出来。

4. 确定遍历顺序

对于0-1背包问题一维dp的遍历，nums放在外循环，target在内循环，且内循环倒序。

5. 举例推导dp数组

输入：nums: `[1, 1, 1, 1, 1]`, S: 3，bagSize = (3 + 5) / 2 = 4。dp数组状态变化如下：

![[Pasted image 20240502155742.png|550]]
#### 一维整体代码

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for(int i : nums){
            sum += i;
        }
        int left = 0;
        if(sum < Math.abs(target)){
            return 0;
        }
        if((sum + target) % 2 != 0){ // 是不等于0  
            return 0;
        }else{
            left = (sum + Math.abs(target)) / 2;
        }
        int[] dp = new int[left + 1];
        dp[0] = 1;
        for(int i = 0; i < nums.length; i++){
            for(int j = left; j >= nums[i]; j--){
                dp[j] += dp[j - nums[i]];
            }
        }
        // for(int i = 0; i < nums.length; i++) {
        //     for(int j = 0; j <= left; j++) {
        //         System.out.print(dp[j] + " ");
        //     }
        //     System.out.println("");
        // }
        return dp[left];
    }
}
```

#### 二维整体代码

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {

        int sum = 0;
        for(int i = 0; i < nums.length; i++) {
            sum += nums[i];
        }

        // 注意nums[i] >= 0的题目条件，意味着sum也是所有nums[i]的绝对值之和
        // 这里保证了sum + target一定是大于等于零的，也就是left大于等于零（毕竟我们定义left大于right）
        if(sum < Math.abs(target)){
            return 0;
        }

        // 利用二元一次方程组将left用target和sum表示出来（替换掉right组合），详见代码随想录对此题的分析
        // 如果所求的left数组和为小数，则作为整数数组的nums里的任何元素自然是没有办法凑出这个小数的
        if((sum + target) % 2 != 0) {
            return 0;
        }

        int left = (sum + target) / 2;
        
        // dp[i][j]：遍历到数组第i个数时， left为j时的能装满背包的方法总数
        int[][] dp = new int[nums.length][left + 1];

        // 初始化最上行（dp[0][j])，当nums[0] == j时（注意nums[0]和j都一定是大于等于零的，因此不需要判断等于-j时的情况），有唯一一种取法可取到j，dp[0][j]此时等于1
        // 其他情况dp[0][j] = 0
        // java整数数组默认初始值为0
        if (nums[0] <= left) {
            dp[0][nums[0]] = 1;
        }

        // 初始化最左列（dp[i][0])
        // 当从nums数组的索引0到i的部分有n个0时（n > 0)，每个0可以取+/-，因此有2的n次方中可以取到j = 0的方案
        // n = 0说明当前遍历到的数组部分没有0全为正数，因此只有一种方案可以取到j = 0（就是所有数都不取）
        int numZeros = 0;
        for(int i = 0; i < nums.length; i++) {
            if(nums[i] == 0) {
                numZeros++;
            }
            dp[i][0] = (int) Math.pow(2, numZeros);

        }

        // 递推公式分析：
        // 当nums[i] > j时，这时候nums[i]一定不能取，所以是dp[i - 1][j]种方案数
        // nums[i] <= j时，num[i]可取可不取，因此方案数是dp[i - 1][j] + dp[i - 1][j - nums[i]]
        // 由递推公式可知，先遍历i或j都可
        for(int i = 1; i < nums.length; i++) {
            for(int j = 1; j <= left; j++) {
                if(nums[i] > j) {
                    dp[i][j] = dp[i - 1][j];
                } else {
                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];
                }
            }
        }

	// 打印dp数组
        // for(int i = 0; i < nums.length; i++) {
        //     for(int j = 0; j <= left; j++) {
        //         System.out.print(dp[i][j] + " ");
        //     }
        //     System.out.println("");
        // }

        return dp[nums.length - 1][left];
        
    }
}
```