### 完全背包

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是`weight[i]`，得到的价值是`value[i]` 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

**完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**。

在下面的讲解中，我依然举这个例子：背包最大重量为4。

物品为：

||重量|价值|
|---|---|---|
|物品0|1|15|
|物品1|3|20|
|物品2|4|30|

**每件商品都有无限个！** 问背包能背的物品最大价值是多少？

0-1背包和完全背包唯一不同就是体现在**遍历顺序上**！我们知道0-1背包内嵌的循环是**从大到小遍历**，为了保证每个物品仅被添加一次。

而完全背包的物品是可以添加多次的，所以要**从小到大去遍历**，即：

```java
// 先遍历物品，再遍历背包
for(int i = 0; i < weight.length; i++) { // 遍历物品
    for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

至于为什么，在[[0-1背包理论基础（二）#^1975e7]]中提到过。其他都和0-1背包问题相似！

dp状态图如下：

![动态规划-完全背包|500](https://code-thinking-1253855093.file.myqcloud.com/pics/20210126104510106.jpg)

**在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是无所谓的！**

遍历物品在外层循环，遍历背包容量在内层循环，状态如图（**先行后列**）：

![[Pasted image 20240502171622.png|500]]

遍历背包容量在外层循环，遍历物品在内层循环，状态如图（**先列后行**）：

![动态规划-完全背包2|500](https://code-thinking-1253855093.file.myqcloud.com/pics/20210729234011.png)

看了这两个图，大家就会理解，完全背包中，两个for循环的先后循序，都不影响计算`dp[j]`所需要的值（这个值就是下标j之前所对应的`dp[j]`）。