![[Pasted image 20240503090625.png|650]]

## 思路

本题题目描述说是求组合，但又说是可以元素相同顺序不同的组合算两个组合，**其实就是求排列！**

组合不强调顺序，(1,5)和(5,1)是同一个组合。排列强调顺序，(1,5)和(5,1)是两个不同的排列。

在学习回溯算法的时候，做过这两道题目[[组合总和]]和[[组合总和 II]]会感觉和本题很像！

但其本质是本题求的是排列总和，而且仅仅是求排列总和的个数，并不是把所有的排列都列出来。**如果本题要把排列都列出来的话，只能使用回溯算法爆搜**。

#### 动规五部曲

1. 确定dp数组以及下标的含义

**`dp[i]`: 凑成目标正整数为i的排列个数为`dp[i]`**

2. 确定递推公式

`dp[i]`（考虑`nums[j]`）可以由 `dp[i - nums[j]]`（不考虑`nums[j]`） 推导出来。

因为只要得到`nums[j]`，排列个数`dp[i - nums[j]]`，就是`dp[i]`的一部分。

在[[目标和]] 和[[零钱兑换 II]]中已经讲过了，求装满背包有几种方法，递推公式一般都是`dp[i] += dp[i - nums[j]]`。

3. dp数组如何初始化

`dp[0]`要初始化为1，这样递归其他`dp[i]`的时候才会有数值基础。非0下标的`dp[i]`应该初始化为0，这样才不会影响`dp[i]`累加所有的`dp[i - nums[j]]`。

4. 确定遍历顺序

个数可以不限使用，说明这是一个完全背包。

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。

所以本题遍历顺序最终遍历顺序：**target（背包）放在外循环，将nums（物品）放在内循环，内循环从前到后遍历**。

5. 举例来推导dp数组

我们再来用示例中的例子推导一下：

![377.组合总和Ⅳ|500](https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000625.png)

#### 整体代码

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        // int sum = 0;
        // for(int i : nums){
        //     sum += i;
        // }
        // if(sum < target){ 这是完全背包问题，这个判断就不合理了
        //     return 0;
        // }
        int[] dp = new int[target + 1];
        dp[0] = 1;
        for(int j = 0; j <= target; j++){ // 先遍历背包再遍历物品，求排序组合问题
            for(int i = 0; i < nums.length; i++){
                if(nums[i] <= j){ // 一定要判断准确
                    dp[j] += dp[j - nums[i]];
                }
            }
        }
        return dp[target];  
    }
}
```
