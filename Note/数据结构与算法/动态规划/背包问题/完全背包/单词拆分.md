![[Pasted image 20240503115335.png|650]]

### 回溯算法

看到这道题目的时候，应该回想起之前在回溯法专题的时候，讲过的一道题目[[分割回文串]]，就是枚举字符串的所有分割情况。

本道是枚举分割所有字符串，判断是否在字典里出现过。

```java
// 回溯法+记忆化
class Solution {
    private Set<String> set;
    private int[] memo;
    public boolean wordBreak(String s, List<String> wordDict) {
        memo = new int[s.length()];
        set = new HashSet<>(wordDict);
        return backtracking(s, 0);
    }

    public boolean backtracking(String s, int startIndex) {
        // System.out.println(startIndex);
        if (startIndex == s.length()) {
            return true;
        }
        if (memo[startIndex] == -1) {
            return false;
        }

        for (int i = startIndex; i < s.length(); i++) {
            String sub = s.substring(startIndex, i + 1);
	    // 拆分出来的单词无法匹配
            if (!set.contains(sub)) {
                continue;                
            }
            boolean res = backtracking(s, i + 1);
            if (res) return true;
        }
        // 这里是关键，找遍了startIndex~s.length()也没能完全匹配，标记从startIndex开始不能找到
        memo[startIndex] = -1;
        return false;
    }
}
```

### 背包问题

单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。

拆分时可以重复使用字典中的单词，说明就是一个完全背包！

动规五部曲分析如下：

1. 确定dp数组以及下标的含义

**`dp[i]` : 字符串长度为i的话，`dp[i]`为true，表示可以拆分为一个或多个在字典中出现的单词**。

2. 确定递推公式

如果确定`dp[j]`是true，且`[j, i]`这个区间的子串出现在字典里，那么`dp[i]`一定是true。( j < i )。

所以递推公式是 `if([j, i] 这个区间的子串出现在字典里 && dp[j]是true)` 那么 `dp[i] = true`。

3. dp数组如何初始化

从递推公式中可以看出，`dp[i]` 的状态依靠 `dp[j]`是否为true，那么`dp[0]`就是递推的根基，`dp[0]`一定要为true，否则递推下去后面都都是false了。

下标非0的`dp[i]`初始化为false，只要没有被覆盖说明都是不可拆分为一个或多个在字典中出现的单词。

4. 确定遍历顺序

题目中说是拆分为一个或多个在字典中出现的单词，所以这是完全背包。

而本题其实求的是排列数，拿 s = "applepenapple", wordDict =`["apple", "pen"]`举例。

"apple", "pen" 是物品，那么我们要求 物品的组合一定是 "apple" + "pen" + "apple" 才能组成 "applepenapple"。

"apple" + "apple" + "pen" 或者 "pen" + "apple" + "apple" 是不可以的，那么我们就是强调物品之间顺序。所以说，本题一定是 先遍历 背包，再遍历物品。

5. 举例推导`dp[i]`

以输入: s = "leetcode", wordDict = `["leet", "code"]`为例，dp状态如图：

![139.单词拆分](https://code-thinking-1253855093.file.myqcloud.com/pics/20210202162652727.jpg)

#### 整体代码

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        int len = s.length();
        HashSet<String> set = new HashSet<>(wordDict);
        boolean[] dp = new boolean[len + 1];
        dp[0] = true;
        for(int i = 1; i < len + 1; i++){
            for(int j = 0; j < i; j++){
                if(set.contains(s.substring(j, i)) && dp[j]){
                    dp[i] = true;
                }
            }
        }
        return dp[len];
    }
}
```
