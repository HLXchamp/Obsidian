![[Pasted image 20240503104332.png|650]]

## 思路

可能刚看这种题感觉没啥思路，又平方和的，又最小数的。

**来把题目翻译一下：完全平方数就是物品（可以无限件使用），凑个正整数n就是背包，问凑满这个背包最少有多少物品？** 其实和上一道题[[零钱兑换]]是一样一样的！

#### 动规五部曲

1. 确定dp数组（dp table）以及下标的含义

**`dp[j]`：和为j的完全平方数的最少数量为`dp[j]`**

2. 确定递推公式

`dp[j]` 可以由`dp[j - i * i]`推出， `dp[j - i * i] + 1` 便可以凑成`dp[j]`。此时我们要选择最小的`dp[j]`，所以**递推公式：`dp[j] = min(dp[j - i * i] + 1, dp[j])`**。

3. dp数组如何初始化

`dp[0]`表示和为0的完全平方数的最小数量，那么`dp[0]`一定是0。

有同学问题，那0 * 0也算是一种啊，为啥`dp[0]`就是0呢？看题目描述，找到若干个完全平方数（比如 1, 4, 9, 16, ...），题目描述中可没说要从0开始，`dp[0]=0`完全是为了递推公式。

**非0下标的`dp[j]`一定要初始为最大值，这样`dp[j]`在递推的时候才不会被初始值覆盖**。

4. 确定遍历顺序

本题外层for遍历背包，内层for遍历物品，还是外层for遍历物品，内层for遍历背包，都是可以的！

5. 举例推导dp数组

已输入n为5例，dp状态图如下：

![279.完全平方数|500](https://code-thinking-1253855093.file.myqcloud.com/pics/20210202112617341.jpg)

#### 整体代码

其他元素填充为`Integer.MAX_VALUE - 1`（推荐）：

```java
class Solution {
    public int numSquares(int n) {
        if(n == 1){
            return 1;
        }
        int[] dp = new int[n + 1];
        Arrays.fill(dp, Integer.MAX_VALUE - 1);
        dp[0] = 0;
        for(int i = 0; i < n; i++){ // i从0或1都行，不过推荐从1开始，因为0*0不算一种情况
            for(int j = i * i; j <= n; j++){
                dp[j] = Math.min(dp[j], dp[j - i * i] + 1);
            }
        }
        // if(dp[n] == Integer.MAX_VALUE - 1){ // 不会有"凑不成"的情况发生
        //     return -1;
        // }
        return dp[n];
    }
}
```

注：
- 本题如果用`Integer.MAX_VALUE`填充，不需要上一道题的 if 判断：`if (dp[j - i * i] != max)`
，因为在完全平方数这一题不会有"凑不成"的情况发生（ 一定可以用"1"来组成任何一个n）;
- `i`一定要从1开始，如果从0开始，`dp[0] = min (0, Integer.MAX_VALUE + 1) = -2147483648`就都错了！

```java
class Solution {
    public int numSquares(int n) {
        if(n == 1){
            return 1;
        }
        int[] dp = new int[n + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for(int i = 1; i < n; i++){ // i从1开始，和题意一样
            for(int j = i * i; j <= n; j++){
                dp[j] = Math.min(dp[j], dp[j - i * i] + 1);
            }
        }
        // if(dp[n] == Integer.MAX_VALUE){
        //     return -1;
        // }
        return dp[n];
    }
}
```
