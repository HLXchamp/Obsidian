![[Pasted image 20240502171732.png|575]]

## 思路

这是一道典型的背包问题，一看到钱币数量不限，就知道这是一个完全背包。

但本题和纯完全背包不一样，**纯完全背包是凑成背包最大价值是多少，而本题是要求凑成总金额的物品组合个数！**

**组合不强调元素之间的顺序，排列强调元素之间的顺序**。 这一点在回溯算法专题的时候就讲过了。

#### 动规五步曲

1. 确定dp数组以及下标的含义

`dp[j]`：凑成总金额j的货币组合数为`dp[j]`。

2. 确定递推公式

`dp[j]` 就是所有的`dp[j - coins[i]]`（考虑`coins[i]`的情况）相加。

所以**递推公式：`dp[j] += dp[j - coins[i]]`;** 这个递推公式和[[目标和]]这道题里一样！

3. dp数组如何初始化

首先`dp[0]`一定要为1，`dp[0] = 1`是 递归公式的基础。如果`dp[0] = 0` 的话，后面所有推导出来的值都是0了。

下标非0的`dp[j]`初始化为0，这样累计加`dp[j - coins[i]]`的时候才不会影响真正的`dp[j]`。

`dp[0]=1`还说明了一种情况：如果正好选了`coins[i]`后，也就是`j-coins[i] == 0`的情况表示这个硬币刚好能选，此时`dp[0]`为1表示只选`coins[i]`存在这样的一种选法。

4. 确定遍历顺序

纯完全背包的两个for循环的先后顺序都是可以换的。**但本题就不行了！**

因为纯完全背包求得装满背包的最大价值是多少，和凑成总和的元素有没有顺序没关系，即：有顺序也行，没有顺序也行！

先来看外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况：

```java
for (int i = 0; i < coins.size(); i++) { // 遍历物品
    for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量
        dp[j] += dp[j - coins[i]];
    }
}
```

假设：`coins[0] = 1`，`coins[1] = 5`。那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。

**所以这种遍历顺序中`dp[j]`里计算的是组合数！**

如果把两个for交换顺序，代码如下：

```java
for (int j = 0; j <= amount; j++) { // 遍历背包容量
    for (int i = 0; i < coins.size(); i++) { // 遍历物品
        if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]];
    }
}
```

背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。

**此时`dp[j]`里算出来的就是排列数！**

5. 举例推导dp数组

输入: amount = 5, coins = `[1, 2, 5]` ，dp状态图如下，`dp[amount]`为最终结果：

![518.零钱兑换II|500](https://code-thinking-1253855093.file.myqcloud.com/pics/20210120181331461.jpg)

#### 整体代码

```java
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        for(int i = 0; i < coins.length; i++){
            for(int j = coins[i]; j <= amount; j++){
                dp[j] += dp[j - coins[i]];
            }
        } 
        return dp[amount];
    }
}
```
