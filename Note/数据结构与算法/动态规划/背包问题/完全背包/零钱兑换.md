![[Pasted image 20240503095707.png|625]]


## 思路

在[[零钱兑换 II]]中我们已经兑换一次零钱了，这次又要兑换，套路不一样！

题目中说每种硬币的数量是无限的，可以看出是典型的完全背包问题。

#### 动规五部曲

1. 确定dp数组以及下标的含义

**`dp[j]`：凑足总额为j所需钱币的最少个数为`dp[j]`**

2. 确定递推公式

凑足总额为`j - coins[i]`的最少个数为`dp[j - coins[i]]`，那么只需要加上一个钱币`coins[i]`即`dp[j - coins[i]] + 1`就是`dp[j]`，所以`dp[j]` 要取所有 `dp[j - coins[i]] + 1` 中最小的。

**递推公式：`dp[j] = min(dp[j - coins[i]] + 1, dp[j])`！**

3. dp数组如何初始化

首先凑足总金额为0所需钱币的个数一定是0，那么`dp[0] = 0;`

其他下标对应的数值呢？考虑到递推公式的特性，`dp[j]`必须**初始化为一个最大的数**，否则就会在`min(dp[j - coins[i]] + 1, dp[j])`比较的过程中被初始值覆盖。所以下标非0的元素都是应该是最大值`Integer.MAX_VALUE`。

4. 确定遍历顺序

本题求钱币最小个数，**那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数**。

**所以本题的两个for循环的关系是：外层for循环遍历物品，内层for遍历背包或者外层for遍历背包，内层for循环遍历物品都是可以的！**

5. 举例推导dp数组

以输入：coins = `[1, 2, 5]`, amount = 5为例

![322.零钱兑换|500](https://code-thinking-1253855093.file.myqcloud.com/pics/20210201111833906.jpg)

#### 整体代码

除了`dp[0]=0`，初始化其他数用的`Integer.MAX_VALUE - 1`，因为后面加一运算就不会越界了！

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        if(amount == 0){
            return 0;
        }
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, Integer.MAX_VALUE - 1);
        dp[0] = 0;
        for(int i = 0; i < coins.length; i++){
            for(int j = coins[i]; j <= amount; j++){
                dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
            }
        }
        if(dp[amount] == Integer.MAX_VALUE - 1){
            return -1;
        }
        return dp[amount];
    }
}
```

如果其他数初始化为`Integer.MAX_VALUE`，就要加上一个判断是否要做加一运算的操作：

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        if(amount == 0){
            return 0;
        }
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for(int i = 0; i < coins.length; i++){
            for(int j = coins[i]; j <= amount; j++){
                if(dp[j - coins[i]] != Integer.MAX_VALUE){ //防止越界，且这个时候显然是dp[j]更小，不用完成下面判断
                    dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
                }
            }
        }
        if(dp[amount] == Integer.MAX_VALUE){
            return -1;
        }
        return dp[amount];
    }
}
```
