![[Pasted image 20240505210415.png|625]]

## 思路

刚接触这样的题目可能会有点困惑，当前的状态我是偷还是不偷呢？仔细一想，当前房屋偷与不偷取决于前一个房屋和前两个房屋是否被偷了。

所以这里就更感觉到，当前状态和前面状态会有一种依赖关系，那么这种依赖关系都是动规的递推公式。

### 动规五部曲

1. 确定dp数组（dp table）以及下标的含义

**`dp[i]`：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为`dp[i]`**。长度为`nums.length`。

2. 确定递推公式

决定`dp[i]`的因素就是第i房间偷还是不偷。

如果**偷**第 i 房间，那么`dp[i] = dp[i - 2] + nums[i]` ，即：第 i-1 房一定是不考虑的，找出 下标 i-2（包括 i-2）以内的房屋，最多可以偷窃的金额为`dp[i-2]` 加上第i房间偷到的钱。

如果不偷第 i 房间，那么`dp[i] = dp[i - 1]`，即考虑 i-1 房，（**注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点**）

然后`dp[i]`取最大值，即 **`dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);`**

3. dp数组如何初始化

从递推公式可以看出，递推公式的基础就是`dp[0]` 和 `dp[1]`，`dp[0] = nums[0]`，`dp[1]`就是`nums[0]`和`nums[1]`的最大值即：`dp[1] = max(nums[0], nums[1]);`


4. 确定遍历顺序

`dp[i]` 是根据`dp[i - 2]` 和 `dp[i - 1]` 推导出来的，那么一定是从前到后遍历！

5. 举例推导dp数组

以示例二，输入`[2,7,9,3,1]`为例。

![198.打家劫舍|500](https://code-thinking-1253855093.file.myqcloud.com/pics/20210221170954115.jpg)

#### 整体代码

```java
class Solution {
    public int rob(int[] nums) {
        int len = nums.length;
        if (len == 1) {
            return nums[0];
        }
        int[] dp = new int[len];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i < len; i++) {
            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]); // 是加nums[i]
        }
        return dp[len - 1];
    }
}

```

 