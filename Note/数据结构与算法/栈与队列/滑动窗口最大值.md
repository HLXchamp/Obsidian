![[Pasted image 20240314203216.png|650]]

我的第一道<font color="#d83931">困难</font>题！

这道题一定要用<font color="#d83931">双端队列</font>！
#### 思路

此时我们需要一个队列，这个队列呢，放进去窗口里的元素，然后随着窗口的移动，队列也一进一出，每次移动之后，队列告诉我们里面的最大值是什么。

**其实队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。**

那么这个维护元素单调递减的队列就叫做**单调队列，即单调递减或单调递增的队列。单调队列不是对窗口里面的数进行排序，如果排序的话，那和优先级队列没有区别了。**来看一下单调队列如何维护队列里的元素。

![239.滑动窗口最大值|369](https://code-thinking.cdn.bcebos.com/gifs/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.gif)

对于窗口里的元素{2, 3, 5, 1 ,4}，单调队列里只维护{5, 4} 就够了，保持单调队列里单调递减，此时队列出口元素就是窗口里最大元素。设计单调队列的时候，pop，和push操作要保持如下规则：

1. pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作；
2. push(value)：如果push的元素value大于<font color="#d83931">入口元素</font>的数值，那么就<font color="#d83931">将队列入口的元素弹出</font>，直到push元素的数值小于等于队列入口元素的数值为止。一定是和入口元素比较，而不是出口！
3. 若`nums = [3,-5,-1,5,3,6,7]`, 和 k = 3，第一步`push(3)`，第二步`push(-5)`，第三步发现`-1>-5`，于是`pop(-5)`，`push(-1)`。

保持如上规则，每次窗口移动的时候，只要问`que.front()`就可以返回当前窗口的最大值。以题目示例为例，输入: `nums = [1,3,-1,-3,5,3,6,7]`, 和 k = 3，动画如下：

![239.滑动窗口最大值-2|450](https://code-thinking.cdn.bcebos.com/gifs/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-2.gif)

使用<font color="#d83931">双端队列deque</font>来实现这个单调队列最为合适。
#### 代码实现

自己写的时候代码总是很繁琐，对于队列的移动时，我是这样写的：

```java
        for(int i = 0; i < k; i++){
            if(deque.isEmpty()){
                deque.add(nums[i]);            
            }
            else if(nums[i] > deque.peek()){
                deque.clear();
                deque.add(nums[i]);
            }
            else if(nums[i] <= deque.peek() && nums[i] <= deque.peekLast()) {
                deque.add(nums[i]);
            }
            else{
                deque.pollLast();
                deque.add(nums[i]);
            }
        }
```

其实只需要一个while就能实现全部：

```java
        for(int i = 0; i < k; i++){
            while (!deque.isEmpty() && nums[i] > deque.peekLast()) {
                deque.pollLast();
            }
        }

```

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if(nums.length == 1){
            return nums;
        }
        Deque<Integer> deque = new LinkedList<>();
        int len = nums.length - k + 1;
        int m = 0;
        int[] res = new int[len];
        for(int i = 0; i < k; i++){
            while (!deque.isEmpty() && nums[i] > deque.peekLast()) {
                deque.pollLast();
            }
            deque.offer(nums[i]);
        }
        res[m++] = deque.peek();
        for(int i = k; i < nums.length; i++){
            if(!deque.isEmpty() && deque.peek() == nums[i - k]){
                deque.poll();
            }
            while (!deque.isEmpty() && nums[i] > deque.peekLast()) {
                deque.pollLast();
            }
            deque.offer(nums[i]);
            res[m++] = deque.peek();
        }
        return res;
    }
}
```
