![[Pasted image 20240313201908.png|675]]

本题要删除相邻相同元素，和[[有效的括号]]来说有异曲同工之妙。

![1047.删除字符串中的所有相邻重复项|322](https://code-thinking.cdn.bcebos.com/gifs/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.gif)

有三种方法：
##### 一、新建一个栈

有一个难点是将栈里的元素转化为字符串，可以用下面方法，其他方法和[[有效的括号]]差不多：

```java
    String res = "";
    while(!stack.isEmpty()){
        res = stack.pop() + res;
    }
    return res;
```

```java
class Solution {
    public String removeDuplicates(String s) {
        Stack<Character> stack = new Stack<>();
        for(int i = 0; i < s.length(); i++){
            char ch = s.charAt(i);
            if(stack.isEmpty() || ch != stack.peek()){
                stack.push(ch);
            }
            else{
                stack.pop();
            }
        }
        String res = "";
        while(!stack.isEmpty()){
            res = stack.pop() + res;
        }
        return res;
    }
}
```
##### 二、将字符串当作栈

省去了栈还要转为字符串的操作，要快一些：

![[Pasted image 20240313210230.png|325]]

```java
class Solution {
    public String removeDuplicates(String s) {
        StringBuilder res = new StringBuilder(); // 将 res 当做栈
        int top = -1;  // top为 res 的长度
        for(int i = 0; i < s.length(); i++){
            char ch = s.charAt(i);
            if(top >= 0 && ch == res.charAt(top)){
                res.deleteCharAt(top);
                top--;
            }
            else{
                res.append(ch);
                top++;
            }
        }
        return res.toString();
    }
}
```

变长字符串的声明和相关操作都要熟悉！！
##### 三、双指针法（拓展）

```java
class Solution {
    public String removeDuplicates(String s) {
        char[] ch = s.toCharArray();
        int fast = 0;
        int slow = 0;
        while(fast < s.length()){
            // 直接用fast指针覆盖slow指针的值
            ch[slow] = ch[fast];
            // 遇到前后相同值的，就跳过，即slow指针后退一步，下次循环就可以直接被覆盖掉了
            if(slow > 0 && ch[slow] == ch[slow - 1]){
                slow--;
            }else{
                slow++;
            }
            fast++;
        }
        return new String(ch,0,slow);
    }
}
```
