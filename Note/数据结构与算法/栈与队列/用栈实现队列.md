![[Pasted image 20240312112714.png|675]]
![[Pasted image 20240312112739.png|575]]

使用栈来模式队列的行为，如果仅仅用一个栈，是一定不行的，所以需要两个栈**一个输入栈，一个输出栈**，这里要注意输入栈和输出栈的关系。

下面动画模拟以下队列的执行过程：

执行语句：  

```java
queue.push(1);  
queue.push(2); 
queue.pop(); // 注意此时的输出栈的操作
queue.push(3);  
queue.push(4);  
queue.pop();  
queue.pop(); // 注意此时的输出栈的操作
queue.pop();  
queue.empty();
```

![232.用栈实现队列版本2|475](https://code-thinking.cdn.bcebos.com/gifs/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif)

在push数据的时候，只要数据放进输入栈就好，**但在pop的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入）**，再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。

最后如何判断队列为空呢？**如果进栈和出栈都为空的话，说明模拟的队列为空了。**

```java
class MyQueue {
    Stack<Integer> stackIn;
    Stack<Integer> stackOut;

    public MyQueue() {
        stackIn = new Stack<>(); // 负责进栈
        stackOut = new Stack<>(); // 负责出栈
    }
    
    public void push(int x) {
        stackIn.push(x);
    }
    
    public int pop() {
        move();
        return stackOut.pop();

    }
    
    public int peek() {
        move();
        return stackOut.peek();

    }
    
    public boolean empty() {
        return (stackIn.isEmpty() && stackOut.isEmpty());
    }

    public void move() {
        if (!stackOut.isEmpty()) return; 
        while (!stackIn.isEmpty()){
            stackOut.push(stackIn.pop());
        }
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```

###### 注意：
- 在代码实现的时候，会发现`pop()` 和 `peek()`两个函数功能类似，代码实现上也是类似的，可以思考一下如何把代码抽象一下。
- **一定要懂得复用，功能相近的函数要抽象出来，不要大量的复制粘贴，很容易出问题！**