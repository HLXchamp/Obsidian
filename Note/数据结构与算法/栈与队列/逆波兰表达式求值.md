![[Pasted image 20240314103047.png|500]]
![[Pasted image 20240314103138.png|625]]
#### 逆波兰式

逆波兰式（RPN，或逆波兰记法），也叫后缀表达式（将运算符写在操作数之后）。

我们习惯看到的表达式都是中缀表达式，因为符合我们的习惯，但是中缀表达式对于计算机来说就不是很友好了。例如：4 + 13 / 5，这就是中缀表达式，计算机从左到右去扫描的话，扫到13，还要判断13后面是什么运算符，还要比较一下优先级，然后13还和后面的5做运算，做完运算之后，还要向前回退到 4 的位置，很麻烦！

那么将中缀表达式，转化为后缀表达式之后：`["4", "13", "5", "/", "+"]` ，就不一样了，计算机可以利用栈来顺序处理，不需要考虑优先级了。也不用回退了， **所以后缀表达式对计算机来说是非常友好的。**


```java
(a+b)*c-(a+b)/e的后缀表达式为：

→((a+b)*c)((a+b)/e)-
→((a+b)c*)((a+b)e/)-
→(ab+c*)(ab+e/)-
→ab+c*ab+e/-
```
#### 用栈处理

在上一篇文章中[[删除字符串中的所有相邻重复项]]提到了**递归就是用栈来实现的**。所以**栈与递归之间在某种程度上是可以转换的！** 这一点在后续二叉树的时候会更详细的讲解到。

**其实逆波兰表达式相当于是二叉树中的后序遍历**。 大家可以把运算符作为中间节点，按照后序遍历的规则画出一个二叉树。但我们没有必要从二叉树的角度去解决这个问题，只要知道逆波兰表达式是用后序遍历的方式把二叉树序列化了，就可以了。

在进一步看，本题中每一个子表达式要得出一个结果，然后拿这个结果再进行运算，那么**这岂不就是一个相邻字符串消除的过程，和[[删除字符串中的所有相邻重复项]]中的对对碰游戏非常像了。只不过本题不要相邻元素做消除了，而是做运算！**

 ![150.逆波兰表达式求值|344](https://code-thinking.cdn.bcebos.com/gifs/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.gif)

自己写的（较为繁琐）：

```java
class Solution {
    public int evalRPN(String[] tokens) {
        Stack<Integer> stack = new Stack();
        for(int i = 0; i < tokens.length; i++){
            if("+".equals(tokens[i]) || "-".equals(tokens[i]) || "*".equals(tokens[i]) || "/".equals(tokens[i])){
                int num1 = stack.pop();
                int num2 = stack.pop();
                if("+".equals(tokens[i])){
                    int res = num1 + num2;
                    stack.push(res);
                }
                else if("-".equals(tokens[i])){
                    int res = num2 - num1;
                    stack.push(res);
                }
                else if("*".equals(tokens[i])){
                    int res = num1 * num2;
                    stack.push(res);
                }
                else{
                    int res = num2 / num1;
                    stack.push(res);
                }
            }
            else{
                stack.push(Integer.parseInt(tokens[i]));
            }
        }
        return stack.pop();
    }
}
```

简化版本：

```java
class Solution {
    public int evalRPN(String[] tokens) {
        Stack<Integer> stack = new Stack();
        for(String s : tokens){
            if("+".equals(s)){
                stack.push(stack.pop() + stack.pop());
            }
            else if("-".equals(s)){
                stack.push(-stack.pop() + stack.pop());
            }
            else if("*".equals(s)){
                stack.push(stack.pop() * stack.pop());
            }
            else if("/".equals(s)){
                int num1 = stack.pop();
                int num2 = stack.pop();
                int res = num2 / num1;
                stack.push(res);
            }
            else{
                stack.push(Integer.valueOf(s));
            }
        }
        return stack.pop();
    }
}
```
