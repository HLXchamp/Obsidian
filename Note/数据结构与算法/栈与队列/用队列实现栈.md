![[Pasted image 20240312105633.png|675]]
![[Pasted image 20240312105705.png|425]]

**队列模拟栈，其实一个队列就够了**，**一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了。**

![[Pasted image 20240312110802.png|550]]

```java
class MyStack {
    public Queue<Integer> queue;

    public MyStack() {
        queue = new ArrayDeque<>();
    }
    
    public void push(int x) {
        queue.add(x);
    }
    
    public int pop() {
        move();
        return queue.remove();
    }
    
    public int top() {
        return ((ArrayDeque<Integer>) queue).peekLast();
    }
    
    public boolean empty() {
        return queue.isEmpty();
    }

    public void move() {
        int len = queue.size();
        len--;
        while(len > 0){
            queue.offer(queue.poll());
            len--;
        }
    }
}

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * boolean param_4 = obj.empty();
 */
```

##### top()方法有两个实现方法：
###### 1、 一个是直接调用方法返回队列尾部的元素：
```java
return ((ArrayDeque<Integer>) queue).peekLast();
```
为什么之前声明了quene是`ArrayDeque<Integer>` 类型吗，为什么之后还要强制转换呢？

在类的声明中，`queue` 被声明为 `Queue<Integer>` 类型，而不是 `ArrayDeque<Integer>` 类型。尽管在构造函数中 `queue` 被实例化为 `ArrayDeque<>`，但是**在类的外部**，它仍然是 `Queue<Integer>` 类型。所以在 `top()` 方法中，如果你想要调用 `ArrayDeque` 特有的 `peekLast()` 方法，你需要将 `queue` 强制转换为 `ArrayDeque<Integer>` 类型，以便调用该方法。
###### 2、 用我们自己写的move()方法：
```java
public int top() {
        move();
        int result = queue.remove(); 
        queue.add(result);
        return result;   
}
```
因为top只是查询，所以move后要把第一个元素移到后面去！

注意：
`while(len--)`和`while(len) {len--}`是一样的！