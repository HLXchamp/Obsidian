![[Pasted image 20230927112913.png]]

```c
int searchInsert(int* nums, int numsSize, int target){
    int left = 0;
    int right = numsSize-1; //注意范围
    int middle = 0;
    while(left <= right){ //注意是小于等于
        middle = left+(right-left)/2; //防止内存溢出
        if(nums[middle] == target){
            return middle;
        }
        else if(nums[middle] < target){
            left = middle+1;
        }
        else{
            right = middle-1;
        }
    }
    return left; //直接返回left就好
}
```

对于二分法，要考虑左右区间的状态，如果是左闭右闭，[left, right]，则判定条件是 
`while(left <= right)`，之后`left = middle+1`，`right = middle-1`。
如果是左闭右开，[left, right) 则判定条件是 
`while(left < right)`，之后`left = middle+1`，`right = middle`。

 防止内存溢出：可以做位运算或者`middle = left+(right-left)/2; `

```java
class Solution {
    public int search(int[] nums, int target) {
        int front = 0;
        int last = nums.length - 1;
        while(front <= last){ //front等于last时有意义
            int middle = front + ((last - front) >> 1) ; //middle写在里面更好，注意写法，右移比除以2好
            if(nums[middle] == target){
                return middle;
            }
            else if(nums[middle] < target){
                front = middle + 1;
            }
            else{
                last = middle - 1; //不减一就会超出时间限制
            }
        }
        return -1;
    }
}
```


![[Pasted image 20230927193935.png]]
方法一：找到相等的target后用暴力算法while分别计算起始和结尾的值，但它们的时间复杂度最坏情况下为 O(n)，总体时间复杂度为 O(log n + n)，近似为 O(n)，不符题意。

方法二：二分查找
```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* searchRange(int* nums, int numsSize, int target, int* returnSize){
    int left = 0;
    int right = numsSize-1;
    int middle = 0;
    int i = -1;
    int j = -1;
    while(left <= right){
        middle = left + (right-left)/2;
        if(nums[middle] == target){
            i = middle - 1;
            j = middle + 1;
            while(i >= 0 && nums[i] == target){
                i--;
            }
            i++;
            while(j < numsSize && nums[j] == target){
                j++;
            }
            j--;
            break;
        }
        else if(nums[middle] < target){ //向左找起始点
            left = middle+1;
        }
        else{ //向右找终止点
            right = middle-1;
        }
    }
    int* result = (int*)malloc(2 * sizeof(int)); //为数组分配内存
    result[0] = i;
    result[1] = j;
    *returnSize = 2; //返回的数组长度
    return result; //返回一个数组
}
```

![[Pasted image 20240116103442.png]]

方法一：逐步逼近，时间复杂度为O(√x)

```c
int mySqrt(int x){
    long j = x/2;
    if(x == 1){
        return 1;
    }
    else{
        while(1){
            if(j*j == x || ((j+1)*(j+1) > x && j*j < x)){
                break; 
            }
            else if(j*j > x){
                j = j/2;
            }
            else{
                j++;
            }
        }
    }
    return j;
}
```

方法二：二分查找，时间复杂度为O(log n)

```c
int mySqrt(int x){
    int left = 1;
    int right = x;
    long middle = 0;
    while(left <= right){
        middle = left + (right-left)/2;
        if(middle == x/middle){
            return middle;
        }
        else if(middle < x/middle){
            left = middle + 1;
        }
        else{
            right = middle - 1;
        }
    }
    return right;
}
```
