数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。

这个题目暴力的解法就是两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。
```c++
// 时间复杂度：O(n^2)
// 空间复杂度：O(1)
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int size = nums.size();
        for (int i = 0; i < size; i++) {
            if (nums[i] == val) { // 发现需要移除的元素，就将数组集体向前移动一位
                for (int j = i + 1; j < size; j++) {
                    nums[j - 1] = nums[j];
                }
                i--; // 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位
                size--; // 此时数组的大小-1
            }
        }
        return size;

    }
};
```

#### 双指针法

双指针法（快慢指针法）：**通过一个快指针和慢指针在一个for循环下完成两个for循环的工作**。

定义快慢指针
- 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
- 慢指针：指向更新 新数组下标的位置

![[27.移除元素-双指针法.gif|448]]

**双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。**

![[Pasted image 20240116152250.png]]
![[Pasted image 20240116152312.png]]


```c
int removeElement(int* nums, int numsSize, int val){
    int slow = 0;
    for(int fast = 0;fast < numsSize;fast++){
        if(nums[fast] != val){
            nums[slow++] = nums[fast];
        }
    }
    return slow;
}
```

![[Pasted image 20240116152733.png|700]]
![[Pasted image 20240116152745.png|700]]
![[Pasted image 20240116162120.png|400]]
```c
int removeDuplicates(int* nums, int numsSize){
 if (numsSize == 0) {
        return 0;
    }
    int slow = 0;
    int fast = 1;
    while (fast < numsSize) {
        if (nums[fast] != nums[slow]) {
            slow++;  //先移slow再赋值
            nums[slow] = nums[fast];
        }
        fast++;
    }
    return slow + 1;
}
```

![[Pasted image 20240116180128.png|650]]
```c
void moveZeroes(int* nums, int numsSize) {
    int fast = 0;
    int slow = 0;
    while(fast < numsSize){
        if(nums[fast] != 0){
            nums[slow++] = nums[fast]; //可以直接赋值
        }
        fast++;
    }
    while(slow < numsSize){
        nums[slow++] = 0;  //把后面的都赋为0
    }
}
```
![[Pasted image 20240116184018.png]]
![[Pasted image 20240117110421.png|350]]
```c
bool backspaceCompare(char* s, char* t) {
    int fast = 0;
    int slow = 0;
    int len_s = strlen(s);
    int len_t = strlen(t);
    while(fast < len_s){
        if(s[fast] == '#'){
            if(slow > 0) //保证不越界
                slow--;
        }else{
            s[slow] = s[fast];
            slow++;
        }
        fast++;
    }
    s[slow] = '\0';
    fast = slow =0;

    while(fast < len_t){
        if(t[fast] == '#'){
            if(slow > 0)
                slow--;
        }else{
            t[slow] = t[fast];
            slow++;
        }
        fast++;
    }
    t[slow] = '\0';

    return strcmp(s, t) == 0;
}
```
在处理退格字符时，应该检查slow是否大于0，然后才执行--slow，以确保不越界；
只有当前字符不是 `#`时，才将当前字符复制到 `slow` 指针指向的位置，然后将 `slow` 向前移动一个位置。

