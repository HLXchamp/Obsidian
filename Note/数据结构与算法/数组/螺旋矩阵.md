![[Pasted image 20240119104456.png]]

像之前的二分法一样，也要有**循环不变量**，我们这里画一条边都要坚持一致的**左闭右开**，这样四条边遍历的方法都是一样的。

![[Pasted image 20240119163522.png|300]]

遍历圈数应该是**n/2**向下取整（找规律），其中n如果是奇数，遍历完n/2次后就只剩下最中间的一个元素了。
对于每一条边，遍历的时候还要控制它的**终止位置**（offset），因为每一次遍历圈数后的终止位置要变。然后对于每一条边分别遍历即可。赋值的基本思路是设定一个**计数值**（count）从1开始每遍历一个数就加一。

```c
int** generateMatrix(int n, int* returnSize, int** returnColumnSizes) {
    // 初始化返回的结果数组的大小
    *returnSize = n;
    *returnColumnSizes = (int*)malloc(sizeof(int) * n);
    
    // 初始化返回结果数组 arr
    int** arr = (int**)malloc(sizeof(int*) * n);
    int i;
    for (i = 0; i < n; i++) {
        arr[i] = (int*)malloc(sizeof(int) * n);
        (*returnColumnSizes)[i] = n;
    }

    int startx = 0; // 起始边，在单圈循环时不变
    int starty = 0;
    int offset = 1;
    int count = 1;
    int loop = n / 2; // 应该转 n/2 圈

    while (loop) { 
        int i = startx;
        int j = starty;
        // 从左到右
        for (; j < n - offset; j++) {
            arr[startx][j] = count++;
        }
        // 从上到下
        for (; i < n - offset; i++) {
            arr[i][j] = count++; // 上一轮的 j 已经循环到最右边了，可以直接用 j
        }
        // 从右到左
        for (; j > starty; j--) { // 此时 i 和 j 都是最大值了
            arr[i][j] = count++; 
        }
        // 从下到上
        for (; i > startx; i--) {
            arr[i][j] = count++;
        }
        startx++;
        starty++;
        offset++;
        loop--; // 一定要减，不然会一直循环
    }
    // 处理中心元素，当 n 为奇数时
    if (n % 2) {  //n % 2与n % 2 ！= 0 是一样的
        arr[startx][starty] = count;
    }
    return arr;
}
```

**出错的地方：**
数组初始化不太会；
`while (loop)` 这里忘记减loop导致一直循环；
四个`for`循环和`startx，starty`不太熟练；
`arr[startx][starty] = count;`这里的`=`写成了`==`

![[Pasted image 20240121142056.png|650]]
![[Pasted image 20240121142129.png|409]]

和上一道题差不多，不过这个是读数组中的值，
最主要的是处理**行数列数不相等的情况**，这时候转的圈数应该是行列数较小的一个的一半；
还有一个是怎么处理转完后里面元素的值，因为行列数不相等的话中间不止一个值，就要多一点步骤，先比较`row`与`col`的大小，选小的一个作为条件进行下面的`for`遍历：`if(row <= col && row % 2)`。后面遍历一定要注意是**小于等于**`if(row <= col && row % 2)`。

```c
int* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize) {
    int row = matrixSize; //行数
    int col = matrixColSize[0]; //列数
    if (row == 0 || col == 0) {
        *returnSize = 0;
        return NULL;
    }
    int *arr = (int *)malloc(row * col * sizeof(int));
    *returnSize = row * col;

    int startx = 0; //起始边，在单圈循环时不变
    int starty = 0;
    int offset = 1;
    int count = 0; //表示arr数组中的下标
    int loop = row < col ? row/2 : col/2; //先选行列数较小的一个，圈数是它的一半
    while(loop){ 
        int i = startx;
        int j = starty;
        for(; j < col - offset; j++){  //注意行row与列col的使用
            arr[count++] = matrix[startx][j];
        }
        for(; i < row - offset; i++){
            arr[count++] = matrix[i][j]; //上一轮的j已经循环到最右边了，可以直接用j
        }
        for(; j > starty; j--){ //此时i和j都是最大值了
            arr[count++] = matrix[i][j]; 
        }
        for(; i > startx; i--){
            arr[count++] = matrix[i][j];
        }
        startx++;
        starty++;
        offset++;
        loop--; //一定要减，不然会一直循环
    }
    if(row <= col && row % 2){ //n % 2与n % 2 ！= 0 是一样的
        for(int j = starty; j <= col - offset; j++){
            arr[count++] = matrix[startx][j];
        }
    }else if(col < row && col % 2){
        for(int i = startx; i <= row - offset; i++){
            arr[count++] = matrix[i][starty];
        }
    }
    return arr;
}
```

**出错的地方：**
最后遍历应该是小于等于`j <= col - offset`；
最后一定要有一个`row = col`的情况。