![[Pasted image 20240123170503.png]]
![[Pasted image 20240124212626.png|575]]

包含了5个重要的函数：
- 获取链表第index个节点的数值
- 在链表的最前面插入一个节点
- 在链表的最后面插入一个节点
- 在链表第index个节点前面插入一个节点
- 删除链表的第index个节点

![[Pasted image 20240124204920.png|625]]
注意事项：
- 这个题必须用虚拟头指针，参数都是一级指针，头节点确定后没法改指向了
- 添加节点时，要注意顺序，要先`newNode->next = cur->next;`再`cur->next = newNode;`
- 有索引index时最好用for循环
- 一定要注意判断不能有空指针，也不能索引越界，例如在添加结点时：
```c
 if (cur == NULL) {
        free(newNode);
        return;
    }
```
- 临时变量要free掉 
- 其他细节条件见注释，一定要细心并理清链表的逻辑

```c
typedef struct MyLinkedList{
    int val;
    struct MyLinkedList* next;
} MyLinkedList;

MyLinkedList* myLinkedListCreate() {
    //这个题必须用虚拟头指针,参数都是一级指针,头节点确定后没法改指向了!!!
    MyLinkedList* dummy = (MyLinkedList*)malloc(sizeof(MyLinkedList));
    dummy->next = NULL;
    return dummy;
}

int myLinkedListGet(MyLinkedList* obj, int index) {
    MyLinkedList *cur = obj->next;//这个obj是指向头节点的,cur要用MyLinkedList赋值
    for(int i = 0; cur != NULL; i++){ //这里可以省略i < index
        if(i == index){
            return cur->val;
        }
        else{
            cur = cur->next;
        }
    }
    return -1; //不存在或者链表为空返回-1
}

void myLinkedListAddAtHead(MyLinkedList* obj, int val) {
    MyLinkedList* newNode = (MyLinkedList*)malloc(sizeof(MyLinkedList));
    newNode->val = val; //不要忘了赋值
    newNode->next = obj->next;
    obj->next = newNode;
}

void myLinkedListAddAtTail(MyLinkedList* obj, int val) {
    MyLinkedList* newNode = (MyLinkedList*)malloc(sizeof(MyLinkedList));
    newNode->val = val;
    newNode->next = NULL; //尾节点指向下一个就是NULL
    MyLinkedList *cur = obj;//之后要用cur->next作为循环条件，这里就先不指向next，防止头节点为空
    while(cur->next != NULL){
        cur = cur->next;
    }
    cur->next = newNode;
}

void myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) {
    if(index == 0){
        myLinkedListAddAtHead(obj, val);
        return;
    }
    MyLinkedList* newNode = (MyLinkedList*)malloc(sizeof(MyLinkedList));
    newNode->val = val;
    MyLinkedList *cur = obj;
    while(index && cur != NULL){  //代码随想录里用的for
        cur = cur->next;
        index--;
    }
    if (cur == NULL) {
        // 处理索引越界的情况
        free(newNode);
        return;
    }
    newNode->next = cur->next;
    cur->next = newNode;
}

void myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) {
    if (index == 0){
        MyLinkedList *temp = obj->next;
        if (temp != NULL){
            obj->next = temp->next;
            free(temp);   //临时变量要free掉  
        }
        return;
    }
    MyLinkedList *cur = obj->next;
    for (int i = 1 ;cur != NULL; i++){ //确保在删除节点时不会越界
        if (i == index){
            MyLinkedList *temp = cur->next;
            if (temp != NULL) {
                cur->next = temp->next;
                free(temp);
            }
            return;
        }
        else{
            cur = cur->next;
        }
    }
}

void myLinkedListFree(MyLinkedList* obj) {
    while(obj != NULL){
        MyLinkedList *temp = obj; //临时指针，释放先前保存的节点的内存
        obj = obj->next;
        free(temp);
    }
}
```
